var documenterSearchIndex = {"docs":
[{"location":"tutorials/continuation/#Solve-BVP-with-Continuation","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"Continuation is a commonly used technique for solving numerically difficult boundary value problems, we exploit the priori knowledge of the solution as initial guess to accelerate the BVP solving by breaking up the difficult BVP into a sequence of simpler problems. For example, we use the problem from Ascher et al. [3] in this tutorial:\n\nε y + xy = ε pi^2cos(pi x) - pi xsin(pi x)\n\nfor ε = 10^-4, on tin-11 with two point boundary conditions y(-1)=-2, y(1)=0. With analytical solution of y(x) = cos(pi x) + operatornameerf(xsqrt2ε)operatornameerf(1sqrt2ε), this problem has a rapid transition layer at x=0, making it difficult to solve numerically. In this tutorial, we will showcase how to use continuation with BoundaryValueDiffEq.jl to solve this BVP.\n\nWe use the substitution to transform this problem into a first order BVP system:\n\nbeginalign*\ny_1= y_2 \ny_2= -fracxε y_2 - pi^2cos(pi x) - fracpi xε sin(pi x)\nendalign*\n\nSince this BVP would become difficult to solve when 0εll 1, we start the continuation with relatively bigger ε to first obtain a good initial guess for cases when epsilon are becoming extremely small. We can just use the previous solution from BVP solving as the initial guess u0 when constructing a new BVProblem.\n\nusing BoundaryValueDiffEq, Plots\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -t / p * u[2] - pi^2 * cospi(t) - pi * t / p * sinpi(t)\nend\nfunction bc!(res, u, p, t)\n    res[1] = u[1][1] + 2\n    res[2] = u[end][1]\nend\ntspan = (-1.0, 1.0)\nsol = [1.0, 0.0]\ne = 0.1\nfor i in 2:4\n    global e = e / 10\n    prob = BVProblem(f!, bc!, sol, tspan, e)\n    global sol = solve(prob, MIRK4(), dt = 0.01)\nend\nplot(sol, idxs = [1])\n\nIn the iterative solving, the intermediate solutions are each used as the initial guess for the next problem solving.","category":"section"},{"location":"tutorials/continuation/#On-providing-initial-guess","page":"Solve BVP with Continuation","title":"On providing initial guess","text":"There are several ways of providing initial guess in BVProblem/TwoPointBVProblem:\n\nSolution from BVP/ODE solving from SciML packages with ODESolution type.\nVectorOfArray from RecursiveArrayTools.jl.\nDiffEqArray from RecursiveArrayTools.jl.\nFunction handle of the form f(p, t) for specifying initial guess on time span.\nAbstractArray represent only the possible initial condition.","category":"section"},{"location":"references/#References","page":"References","title":"References","text":"P. H. Muir and M. F. Adams. Mono-Implicit Runge-Kutta-Nyström Methods with Application to Boundary Value Ordinary Differential Equations. BIT Numerical Mathematics 41, 776–799 (2001).\n\n\n\nU. M. Ascher and R. J. Spiteri. Collocation software for boundary value differential-algebraic equations. SIAM Journal on Scientific Computing 15, 938–952 (1994).\n\n\n\nU. M. Ascher, R. M. Mattheij and R. D. Russell. Numerical Solution of Boundary Value Problems for Ordinary Differential Equations (Society for Industrial and Applied Mathematics, 1995), arXiv:https://epubs.siam.org/doi/pdf/10.1137/1.9781611971231.\n\n\n\nJ. J. Boisvert, P. H. Muir and R. J. Spiteri. A Runge-Kutta BVODE solver with global error and defect control. ACM Transactions on Mathematical Software (TOMS) 39, 1–22 (2013).\n\n\n\nM. Kelly. An introduction to trajectory optimization: How to do your own direct collocation. SIAM review 59, 849–904 (2017).\n\n\n\n","category":"section"},{"location":"tutorials/extremum/#Solve-BVP-with-Extremum-Boundary-Conditions","page":"Solve BVP with Extremum Boundary Conditions","title":"Solve BVP with Extremum Boundary Conditions","text":"In many physical systems, boundary conditions are not always defined at fixed points such as initial or terminal ends of the domain. Instead, we may encounter scenarios where constraints are imposed on the maximum or minimum values that the solution must attain somewhere within the domain. In such cases, we can use the maxsol and minsol functions provided by BoundaryValueDiffEq.jl to specify such extremum boundary conditions.\n\nLet's walk through this functionality with an intuitive example. We still revisit the simple pendulum example here, but this time, suppose we need to impose the maximum and minimum value to our boundary conditions, specified as:\n\nmaxu=ub\nminu=lb\n\nwhere lb=-4.8161991710010925 and ub=5.0496477654230745. So the states must conform that the maximum value of the state should be lb while the minimum value of the state should be ub. To solve such problems, we can simply use the maxsol and minsol functions when defining the boundary value problem in BoundaryValueDiffEq.jl.\n\nusing BoundaryValueDiffEq, Plots\ntspan = (0.0, pi / 2)\nfunction simplependulum!(du, u, p, t)\n    θ = u[1]\n    dθ = u[2]\n    du[1] = dθ\n    du[2] = -9.81 * sin(θ)\nend\nfunction bc!(residual, u, p, t)\n    residual[1] = maxsol(u, (0.0, pi / 2)) - 5.0496477654230745\n    residual[2] = minsol(u, (0.0, pi / 2)) + 4.8161991710010925\nend\nprob = BVProblem(simplependulum!, bc!, [pi / 2, pi / 2], tspan)\nsol = solve(prob, MIRK4(), dt = 0.05)\nplot(sol)","category":"section"},{"location":"solvers/mirk/#mirk","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK","text":"Monotonic Implicit Runge Kutta(MIRK) Methods. To only use the MIRK methods form BoundaryValueDiffEq.jl, you need to install them use the Julia package manager:\n\nusing Pkg\nPkg.add(\"BoundaryValueDiffEqMIRK\")\n\nsolve(prob::BVProblem, alg, dt; kwargs...)\nsolve(prob::TwoPointBVProblem, alg, dt; kwargs...)","category":"section"},{"location":"solvers/mirk/#Full-List-of-Methods","page":"BoundaryValueDiffEqMIRK","title":"Full List of Methods","text":"MIRK2: 2 stage Monotonic Implicit Runge-Kutta method, with defect control adaptivity.\nMIRK3: 3 stage Monotonic Implicit Runge-Kutta method, with defect control adaptivity.\nMIRK4: 4 stage Monotonic Implicit Runge-Kutta method, with defect control adaptivity.\nMIRK5: 5 stage Monotonic Implicit Runge-Kutta method, with defect control adaptivity.\nMIRK6: 6 stage Monotonic Implicit Runge-Kutta method, with defect control adaptivity.","category":"section"},{"location":"solvers/mirk/#Detailed-Solvers-Explanation","page":"BoundaryValueDiffEqMIRK","title":"Detailed Solvers Explanation","text":"","category":"section"},{"location":"solvers/mirk/#BoundaryValueDiffEqMIRK.MIRK2","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK.MIRK2","text":"MIRK2(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n2th order Monotonic Implicit Runge Kutta method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used. Optimization solvers should first be loaded to allow this functionality.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Enright1996RungeKuttaSW,\n    title={Runge-Kutta Software with Defect Control for Boundary Value ODEs},\n    author={Wayne H. Enright and Paul H. Muir},\n    journal={SIAM J. Sci. Comput.},\n    year={1996},\n    volume={17},\n    pages={479-497}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/mirk/#BoundaryValueDiffEqMIRK.MIRK3","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK.MIRK3","text":"MIRK3(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n3th order Monotonic Implicit Runge Kutta method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used. Optimization solvers should first be loaded to allow this functionality.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Enright1996RungeKuttaSW,\n    title={Runge-Kutta Software with Defect Control for Boundary Value ODEs},\n    author={Wayne H. Enright and Paul H. Muir},\n    journal={SIAM J. Sci. Comput.},\n    year={1996},\n    volume={17},\n    pages={479-497}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/mirk/#BoundaryValueDiffEqMIRK.MIRK4","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK.MIRK4","text":"MIRK4(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n4th order Monotonic Implicit Runge Kutta method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used. Optimization solvers should first be loaded to allow this functionality.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Enright1996RungeKuttaSW,\n    title={Runge-Kutta Software with Defect Control for Boundary Value ODEs},\n    author={Wayne H. Enright and Paul H. Muir},\n    journal={SIAM J. Sci. Comput.},\n    year={1996},\n    volume={17},\n    pages={479-497}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/mirk/#BoundaryValueDiffEqMIRK.MIRK5","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK.MIRK5","text":"MIRK5(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n5th order Monotonic Implicit Runge Kutta method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used. Optimization solvers should first be loaded to allow this functionality.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Enright1996RungeKuttaSW,\n    title={Runge-Kutta Software with Defect Control for Boundary Value ODEs},\n    author={Wayne H. Enright and Paul H. Muir},\n    journal={SIAM J. Sci. Comput.},\n    year={1996},\n    volume={17},\n    pages={479-497}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/mirk/#BoundaryValueDiffEqMIRK.MIRK6","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK.MIRK6","text":"MIRK6(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n6th order Monotonic Implicit Runge Kutta method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used. Optimization solvers should first be loaded to allow this functionality.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Enright1996RungeKuttaSW,\n    title={Runge-Kutta Software with Defect Control for Boundary Value ODEs},\n    author={Wayne H. Enright and Paul H. Muir},\n    journal={SIAM J. Sci. Comput.},\n    year={1996},\n    volume={17},\n    pages={479-497}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/wrappers/#wrapper","page":"Wrapper Methods","title":"Wrapper Methods","text":"note: Require ODEInterface\nWrapper methods require ODEInterface.jl loaded\n\nsolve(prob::BVProblem, alg; kwargs...)\nsolve(prob::TwoPointBVProblem, alg; kwargs...)","category":"section"},{"location":"solvers/wrappers/#Full-List-of-Methods","page":"Wrapper Methods","title":"Full List of Methods","text":"BVPM2: Single shooting methods, reduces BVP to an initial value problem and solves the IVP.\nBVPSOL: Reduces BVP to an initial value problem and solves the IVP. Significantly more stable than Single Shooting.\nCOLNEW: Gauss-Legendre collocation methods for BVP with Ascher's error control adaptivity and mesh refinement.","category":"section"},{"location":"api/odeinterface/#ODEInterface.jl","page":"ODEInterface.jl","title":"ODEInterface.jl","text":"This is an extension for importing solvers from ODEInterface.jl into the SciML interface. Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:\n\nusing Pkg\nPkg.add(\"ODEInterface\")\nusing ODEInterface, BoundaryValueDiffEq","category":"section"},{"location":"api/odeinterface/#Solver-API","page":"ODEInterface.jl","title":"Solver API","text":"","category":"section"},{"location":"api/odeinterface/#BoundaryValueDiffEq.BVPM2","page":"ODEInterface.jl","title":"BoundaryValueDiffEq.BVPM2","text":"BVPM2(; max_num_subintervals = 3000, method_choice = 4, diagnostic_output = 1,\n    error_control = 1, singular_term = nothing)\nBVPM2(max_num_subintervals::Int, method_choice::Int, diagnostic_output::Int,\n    error_control::Int, singular_term)\n\nFortran code for solving two-point boundary value problems. For detailed documentation, see ODEInterface.jl.\n\nKeyword Arguments:\n\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nmethod_choice: Choice for IVP-solvers, default as Runge-Kutta method of order 4, available choices:\n2: Runge-Kutta method of order 2.\n4: Runge-Kutta method of order 4.\n6: Runge-Kutta method of order 6.\ndiagnostic_output: Diagnostic output for BVPM2, default as non printout, available choices:\n-1: Full diagnostic printout.\n0: Selected printout.\n1: No printout.\nerror_control: Determines the error-estimation for which RTOL is used, default as defect control, available choices:\n1: Defect control.\n2: Global error control.\n3: Defect and then global error control.\n4: Linear combination of defect and global error control.\nsingular_term: either nothing if the ODEs have no singular terms at the left boundary or a constant (d,d) matrix for the singular term.\n\nnote: Note\nOnly available if the ODEInterface package is loaded.\n\n\n\n\n\n","category":"type"},{"location":"api/odeinterface/#BoundaryValueDiffEq.BVPSOL","page":"ODEInterface.jl","title":"BoundaryValueDiffEq.BVPSOL","text":"BVPSOL(; bvpclass = 2, sol_method = 0, odesolver = nothing)\nBVPSOL(bvpclass::Int, sol_methods::Int, odesolver)\n\nA FORTRAN77 code which solves highly nonlinear two point boundary value problems using a local linear solver (condensing algorithm) or a global sparse linear solver for the solution of the arising linear subproblems, by Peter Deuflhard, Georg Bader, Lutz Weimann. For detailed documentation, see ODEInterface.jl.\n\nKeyword Arguments\n\nbvpclass: Boundary value problem classification, default as highly nonlinear with bad initial data, available choices:\n0: Linear boundary value problem.\n1: Nonlinear with good initial data.\n2: Highly Nonlinear with bad initial data.\n3: Highly nonlinear with bad initial data and initial rank reduction to separable linear boundary conditions.\nsol_method: Switch for solution methods, default as local linear solver with condensing algorithm, available choices:\n0: Use local linear solver with condensing algorithm.\n1: Use global sparse linear solver.\nodesolver: Either nothing or ode-solver(dopri5, dop853, seulex, etc.).\n\nnote: Note\nOnly available if the ODEInterface package is loaded.\n\n\n\n\n\n","category":"type"},{"location":"api/odeinterface/#BoundaryValueDiffEq.COLNEW","page":"ODEInterface.jl","title":"BoundaryValueDiffEq.COLNEW","text":"COLNEW(; bvpclass = 1, collocationpts = 7, diagnostic_output = 1,\n    max_num_subintervals = 3000, bc_func = nothing, dbc_func = nothing,\n    zeta = nothing)\nCOLNEW(bvpclass::Int, collocationpts::Int, diagnostic_output::Int,\n    max_num_subintervals::Int, bc_func, dbc_func, zeta::AbstractVector)\n\nKeyword Arguments:\n\nbvpclass: Boundary value problem classification, default as nonlinear and \"extra sensitive\", available choices:\n0: Linear boundary value problem.\n1: Nonlinear and regular.\n2: Nonlinear and \"extra sensitive\" (first relax factor is rstart and the nonlinear iteration does not rely on past convergence).\n3: fail-early: return immediately upon: a) two successive non-convergences. b) after obtaining an error estimate for the first time.\ncollocationpts: Number of collocation points per subinterval. Require orders[i] ≤ k ≤ 7, default as 7\ndiagnostic_output: Diagnostic output for COLNEW, default as no printout, available choices:\n-1: Full diagnostic printout.\n0: Selected printout.\n1: No printout.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nbc_func: Boundary condition accord with ODEInterface.jl, only used for multi-points BVP.\ndbc_func: Jacobian of boundary condition accord with ODEInterface.jl, only used for multi-points BVP.\nzeta: The points in interval where boundary conditions are specified, only used for multi-points BVP.\n\nA Fortran77 code solves a multi-points boundary value problems for a mixed order system of ODEs. It incorporates a new basis representation replacing b-splines, and improvements for the linear and nonlinear algebraic equation solvers.\n\nwarning: Warning\nOnly supports two-point boundary value problems.\n\nnote: Note\nOnly available if the ODEInterface package is loaded.\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#firk","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"Fully Implicit Runge Kutta(FIRK) Methods. To be able to access the solvers in BoundaryValueDiffEqFIRK, you must first install them use the Julia package manager:\n\nusing Pkg\nPkg.add(\"BoundaryValueDiffEqFIRK\")\n\nsolve(prob::BVProblem, alg, dt; kwargs...)\nsolve(prob::TwoPointBVProblem, alg, dt; kwargs...)","category":"section"},{"location":"solvers/firk/#Nested-nonlinear-solving-in-FIRK-methods","page":"BoundaryValueDiffEqFIRK","title":"Nested nonlinear solving in FIRK methods","text":"When working with large boundary value problems, especially those involving stiff systems, computational efficiency and solver robustness become critical concerns. To improve the efficiency of FIRK methods on large BVPs, we can use nested nonlinear solving to obtain the implicit FIRK step instead of solving them as part of the global residual. In BoundaryValueDiffEq.jl, we can set nested_nlsolve as true to enable FIRK methods to compute the implicit FIRK steps using nested nonlinear solving(default option in FIRK methods is nested_nlsolve=false).\n\nMoreover, the nested nonlinear problem solver can be finely tuned to meet specific accuracy requirements by providing detailed keyword arguments through the nested_nlsolve_kwargs option in any FIRK solver, for example, RadauIIa5(; nested_nlsolve = true, nested_nlsolve_kwargs = (; abstol = 1e-6, reltol = 1e-6)), where nested_nlsolve_kwargs can be any common keyword arguments in NonlinearSolve.jl, see Common Solver Options in NonlinearSolve.jl.","category":"section"},{"location":"solvers/firk/#Full-List-of-Methods","page":"BoundaryValueDiffEqFIRK","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/firk/#Radau-IIA-methods","page":"BoundaryValueDiffEqFIRK","title":"Radau IIA methods","text":"RadauIIa1: 1 stage Radau IIA method, without defect control adaptivity\nRadauIIa2: 2 stage Radau IIA method, with defect control adaptivity.\nRadauIIa3: 3 stage Radau IIA method, with defect control adaptivity.\nRadauIIa5: 5 stage Radau IIA method, with defect control adaptivity.\nRadauIIa7: 7 stage Radau IIA method, with defect control adaptivity.","category":"section"},{"location":"solvers/firk/#Lobatto-IIIA-methods","page":"BoundaryValueDiffEqFIRK","title":"Lobatto IIIA methods","text":"LobattoIIIa2: 2 stage Lobatto IIIa method, with defect control adaptivity.\nLobattoIIIa3: 3 stage Lobatto IIIa method, with defect control adaptivity.\nLobattoIIIa4: 4 stage Lobatto IIIa method, with defect control adaptivity.\nLobattoIIIa5: 5 stage Lobatto IIIa method, with defect control adaptivity.","category":"section"},{"location":"solvers/firk/#Lobatto-IIIB-methods","page":"BoundaryValueDiffEqFIRK","title":"Lobatto IIIB methods","text":"LobattoIIIb2: 2 stage Lobatto IIIb method, without defect control adaptivity.\nLobattoIIIb3: 3 stage Lobatto IIIb method, with defect control adaptivity.\nLobattoIIIb4: 4 stage Lobatto IIIb method, with defect control adaptivity.\nLobattoIIIb5: 5 stage Lobatto IIIb method, with defect control adaptivity.","category":"section"},{"location":"solvers/firk/#Lobatto-IIIC-methods","page":"BoundaryValueDiffEqFIRK","title":"Lobatto IIIC methods","text":"LobattoIIIc2: 2 stage Lobatto IIIc method, without defect control adaptivity.\nLobattoIIIc3: 3 stage Lobatto IIIc method, with defect control adaptivity.\nLobattoIIIc4: 4 stage Lobatto IIIc method, with defect control adaptivity.\nLobattoIIIc5: 5 stage Lobatto IIIc method, with defect control adaptivity.","category":"section"},{"location":"solvers/firk/#Detailed-Solvers-Explanation","page":"BoundaryValueDiffEqFIRK","title":"Detailed Solvers Explanation","text":"","category":"section"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.RadauIIa1","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.RadauIIa1","text":"RadauIIa1(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n1th stage RadauIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@incollection{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    editor={Engquist, Bj{\"o}rn},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.RadauIIa2","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.RadauIIa2","text":"RadauIIa2(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n2th stage RadauIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@incollection{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    editor={Engquist, Bj{\"o}rn},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.RadauIIa3","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.RadauIIa3","text":"RadauIIa3(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n3th stage RadauIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@incollection{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    editor={Engquist, Bj{\"o}rn},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.RadauIIa5","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.RadauIIa5","text":"RadauIIa5(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n5th stage RadauIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@incollection{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    editor={Engquist, Bj{\"o}rn},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.RadauIIa7","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.RadauIIa7","text":"RadauIIa7(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n7th stage RadauIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@incollection{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    editor={Engquist, Bj{\"o}rn},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIa2","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIa2","text":"LobattoIIIa2(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n2th stage LobattoIIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIa3","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIa3","text":"LobattoIIIa3(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n3th stage LobattoIIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIa4","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIa4","text":"LobattoIIIa4(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n4th stage LobattoIIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIa5","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIa5","text":"LobattoIIIa5(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n5th stage LobattoIIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIb2","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIb2","text":"LobattoIIIb2(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n2th stage LobattoIIIb method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIb3","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIb3","text":"LobattoIIIb3(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n3th stage LobattoIIIb method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIb4","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIb4","text":"LobattoIIIb4(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n4th stage LobattoIIIb method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIb5","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIb5","text":"LobattoIIIb5(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n5th stage LobattoIIIb method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIc2","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIc2","text":"LobattoIIIc2(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n2th stage LobattoIIIc method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\ntitle = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\nauthor = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\nyear = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIc3","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIc3","text":"LobattoIIIc3(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n3th stage LobattoIIIc method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\ntitle = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\nauthor = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\nyear = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIc4","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIc4","text":"LobattoIIIc4(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n4th stage LobattoIIIc method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\ntitle = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\nauthor = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\nyear = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIc5","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIc5","text":"LobattoIIIc5(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n5th stage LobattoIIIc method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\ntitle = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\nauthor = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\nyear = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"tutorials/unknown_parameters/#Estimate-Unknown-Parameters-in-BVP","page":"Estimate Unknown Parameters in BVP","title":"Estimate Unknown Parameters in BVP","text":"When there are unknown parameters in boundary value problems, we can estimate the unknown parameters by solving the BVP, it is quite useful in practical applications in dynamical optimizations and inverse problems. This approach allows us to incorporate both the governing differential equations and boundary conditions to infer parameters that may not be directly measurable.\n\nLet's walk through this functionality with an intuitive example. In the following tutorial, we use the Mathieu equation which is a second-order differential equation:\n\ny+(lambda-2qcos(2x))y=0\n\nwhere lambda is the unknown parameter we wish to estimate, q is a known real-valued parameter, with boundary conditions when q=5:\n\ny(0)=0 y(pi)=0\n\nThe second-order BVP can be transformed into a first-order system of BVP:\n\nbegincases\ny_1=y_2\ny_2=-(lambda-2qcos(2x))y_1\nendcases\n\nwith boundary conditions of\n\ny_2(0)=0 y_2(pi)=0\n\nIt is worthnoting that in this system, while we have two differetial equations, it isn't enough to estimate the unknown parameters and guarantee a unique numerical solution with only two given boundary conditions. While under the hood, the parameters are estimated simultaneously with the numerical solution, it makes the boundary value problem an underconstrained BVP if the number of constraints are equal to the number of states, which may result in more than one solution. So we should provide additional constraint y(0)=1 from the original equation to make sure unique numerical solution and the estimated parameters are we actually wanted.\n\nWith BoundaryValueDiffEq.jl, it's easy to solve boundary value problems with unknown parameters, we can just specify fit_parameters=true when constructing the BVP and provide the guess of the unknown parameters in prob.p, for example, to estimate the unknown parameters in the above BVP system:\n\nusing BoundaryValueDiffEq, Plots\ntspan = (0.0, pi)\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -(p[1] - 10 * cos(2 * t)) * u[1]\nend\nfunction bca!(res, u, p)\n    res[1] = u[2]\n    res[2] = u[1] - 1.0\nend\nfunction bcb!(res, u, p)\n    res[1] = u[2]\nend\nguess(p, t) = [cos(4t); -4sin(4t)]\nbvp = TwoPointBVProblem(f!, (bca!, bcb!), guess, tspan, [15.0],\n    bcresid_prototype = (zeros(2), zeros(1)), fit_parameters = true)\nsol = solve(bvp, MIRK4(), dt = 0.05)\nplot(sol)\n\nafter solving the boundary value problem, the estimated unknown parameters can be accessed in the solution\n\nsol.prob.p","category":"section"},{"location":"tutorials/solve_nlls_bvp/#Solve-Overdetermined-and-Underdetermined-BVP","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"When there are more or less boundary conditions than the states in a boundary value problem, the BVP would become an overdetermined or underdetermined boundary value problem. As for these kinds of special BVPs, the solving workflow are similar with solving standard BVPs in BoundaryValueDiffEq.jl, but we need to specify the prototype of boundary conditions to tell BoundaryValueDiffEq.jl the structure of our boundary conditions with bcresid_prototype in BVPFunction.","category":"section"},{"location":"tutorials/solve_nlls_bvp/#Solve-Overdetermined-BVP","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined BVP","text":"For example, consider an overdetermined BVP given by the system of differential equations\n\nbeginalign*\ny_1 =  y_2 \ny_2 = -y_1\nendalign*\n\nwith boundary conditions of\n\nbeginalign*\ny_1(0) = 0 \ny_1(100) = 1 \ny_2(100) = -1729109\nendalign*\n\nThe test BVP has two state variables but three boundary conditions, which means there are additional constraints on the solution.\n\nusing BoundaryValueDiffEq, Plots\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -u[1]\nend\nfunction bc!(resid, sol, p, t)\n    solₜ₁ = sol(0.0)\n    solₜ₂ = sol(100.0)\n    resid[1] = solₜ₁[1]\n    resid[2] = solₜ₂[1] - 1\n    resid[3] = solₜ₂[2] + 1.729109\nend\ntspan = (0.0, 100.0)\nu0 = [0.0, 1.0]\nprob = BVProblem(BVPFunction(f!, bc!; bcresid_prototype = zeros(3)), u0, tspan)\nsol = solve(prob, MIRK4(), dt = 0.01, abstol = 1e-3)\nplot(sol)\n\nSince this BVP imposes constraints only at the two endpoints, we can use TwoPointBVProblem to handle such cases.\n\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -u[1]\nend\nbca!(resid, ua, p) = (resid[1] = ua[1])\nbcb!(resid, ub, p) = (resid[1] = ub[1] - 1; resid[2] = ub[2] + 1.729109)\nbvpfun = BVPFunction(f!, (bca!, bcb!); twopoint = Val(true),\n    bcresid_prototype = (zeros(1), zeros(2)))\nprob = TwoPointBVProblem(bvpfun, u0, tspan)","category":"section"},{"location":"tutorials/solve_nlls_bvp/#Solve-Underdetermined-BVP","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Underdetermined BVP","text":"Let's see an example of underdetermined BVP, consider an horizontal metal beam of length L subject to a vertical load q(x) per unit length, the resulting beam displacement satisfies the differential equation\n\nEIy(x)=q(x)\n\nwith boundary condition y(0)=y(L)=0, E is the Young's modulus and I is the moment of inertia of the beam's cross section. Here we consider the simplified version and transform this BVP into a first order BVP system:\n\nbeginalign*\ny_1 = y_2\ny_2 = y_3\ny_3 = y_4\ny_4 = 0\nendalign*\n\nusing BoundaryValueDiffEq, Plots\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = u[3]\n    du[3] = u[4]\n    du[4] = 0\nend\nfunction bc!(resid, sol, p, t)\n    solₜ₁ = sol(0.0)\n    solₜ₂ = sol(1.0)\n    resid[1] = solₜ₁[1]\n    resid[2] = solₜ₂[1]\nend\nxspan = (0.0, 1.0)\nu0 = [0.0, 1.0, 0.0, 1.0]\nprob = BVProblem(BVPFunction(f!, bc!; bcresid_prototype = zeros(2)), u0, xspan)\nsol = solve(prob, MIRK4(), dt = 0.01)\nplot(sol)\n\nSince this problem has less constraints than the state variables, so there would be infinitely many solutions with different u0 specified.\n\nThe above underdetermined is also being able to reformulated as TwoPointBVProblem\n\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = u[3]\n    du[3] = u[4]\n    du[4] = 0\nend\nbca!(resid, ua, p) = (resid[1] = ua[1])\nbcb!(resid, ub, p) = (resid[1] = ub[1])\nxspan = (0.0, 1.0)\nu0 = [0.0, 1.0, 0.0, 1.0]\nbvpfun = BVPFunction(f!, (bca!, bcb!); twopoint = Val(true),\n    bcresid_prototype = ( zeros(1), zeros(1)))\nprob = TwoPointBVProblem(bvpfun, u0, xspan)","category":"section"},{"location":"devdocs/internal_interfaces/#Internal-Abstract-Types","page":"Internal Abstract Types","title":"Internal Abstract Types","text":"","category":"section"},{"location":"devdocs/internal_interfaces/#Solvers","page":"Internal Abstract Types","title":"Solvers","text":"","category":"section"},{"location":"devdocs/internal_interfaces/#BoundaryValueDiffEqCore.AbstractBoundaryValueDiffEqAlgorithm","page":"Internal Abstract Types","title":"BoundaryValueDiffEqCore.AbstractBoundaryValueDiffEqAlgorithm","text":"AbstractBoundaryValueDiffEqAlgorithm\n\nAbstract type for all boundary value problem algorithms.\n\n\n\n\n\n","category":"type"},{"location":"basics/autodiff/#Automatic-Differentiation-Backends","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"note: Note\nWe support ForwardDiff.jl, FiniteDiff.jl, Enzyme.jl, Mooncake.jl and PolyesterForwardDiff.jl(PolyesterForwardDiff only for collocation methods) via DifferentiationInterface.jl. Please refer to the backends page for more information.\n\nIn BoundaryValueDiffEq.jl, automatic differentiation backend should only be wrapped in BVPJacobianAlgorithm(diffmode, bc_diffmode, nonbc_diffmode). BVPJacobianAlgorithm(diffmode, bc_diffmode, nonbc_diffmode) supports user-specified mixed automatic differentiation backends in different part of a boundary value problem, and AD choice should depended on the type of boundary value problem:\n\nBVProblem: Differentiation mode for boundary condition part and non boundary condition part should be specified, for example, BVPJacobianAlgorithm(; bc_diffmode, nonbc_diffmode), default to BVPJacobianAlgorithm(; bc_diffmode = AutoForwardDiff(), nonbc_diffmode = AutoSparse(AutoForwardDiff())).\nTwoPointBVProblem: Differentiation mode for overall solving should be specified, for example, BVPJacobianAlgorithm(; diffmode), default to BVPJacobianAlgorithm(; diffmode = AutoSparse(AutoForwardDiff())).\n\nIn BoundaryValueDiffEq.jl, we require AD to obtain the Jacobian of the loss function which contains the collocation equation and boundary condition equations. For TwoPointBVProblem, the Jacobian of the loss function is a sparse banded matrix with known sparsity pattern, but for general multi-points BVProblem, the Jacobian of the loss function is an almost banded matrix, which has the first several rows as the boundary conditions and the rest as a sparse banded matrix with known sparsity pattern but without the first several rows. In this case, we can specify mixed AD backend in BVPJacobianAlgorithm to make the most of the different sparsity pattern to accelerate BVP solving process.","category":"section"},{"location":"basics/autodiff/#Summary-of-Finite-Differencing-Backends","page":"Automatic Differentiation Backends","title":"Summary of Finite Differencing Backends","text":"AutoFiniteDiff: Finite differencing using FiniteDiff.jl, not optimal but always applicable.","category":"section"},{"location":"basics/autodiff/#Summary-of-Forward-Mode-AD-Backends","page":"Automatic Differentiation Backends","title":"Summary of Forward Mode AD Backends","text":"AutoForwardDiff: The best choice for dense problems.\nAutoPolyesterForwardDiff: Might be faster than AutoForwardDiff for large problems. Requires PolyesterForwardDiff.jl to be installed and loaded.\nAutoEnzyme(; mode = Enzyme.Forward): Source transformation forward mode AD.","category":"section"},{"location":"basics/autodiff/#Summary-of-Reverse-Mode-AD-Backends","page":"Automatic Differentiation Backends","title":"Summary of Reverse Mode AD Backends","text":"AutoEnzyme(; mode = Enzyme.Reverse): Source transformation reverse mode AD.\nAutoMooncake(; config = nothing): Source transformation reverse mode AD.","category":"section"},{"location":"solvers/ascher/#ascher","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher","text":"Gauss Legendre collocation methods with Ascher's error control adaptivity and mesh refinement routines. To be able to access the solvers in BoundaryValueDiffEqFIRK, you must first install them use the Julia package manager:\n\nusing Pkg\nPkg.add(\"BoundaryValueDiffEqAscher\")\n\nsolve(prob::BVProblem, alg, dt; kwargs...)\nsolve(prob::TwoPointBVProblem, alg, dt; kwargs...)","category":"section"},{"location":"solvers/ascher/#Full-List-of-Methods","page":"BoundaryValueDiffEqAscher","title":"Full List of Methods","text":"Ascher1: 1 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher2: 2 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher3: 3 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher4: 4 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher5: 5 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher6: 6 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher7: 7 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.","category":"section"},{"location":"solvers/ascher/#Detailed-Solvers-Explanation","page":"BoundaryValueDiffEqAscher","title":"Detailed Solvers Explanation","text":"","category":"section"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher1","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher1","text":"Ascher1(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n1th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher2","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher2","text":"Ascher2(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n2th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher3","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher3","text":"Ascher3(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n3th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher4","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher4","text":"Ascher4(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n4th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher5","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher5","text":"Ascher5(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n5th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher6","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher6","text":"Ascher6(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n6th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher7","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher7","text":"Ascher7(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n7th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"basics/solve/#solver_options","page":"Common Solver Options (Solve Keyword Arguments)","title":"Common Solver Options (Solve Keyword Arguments)","text":"abstol::Number: The absolute tolerance. Defaults to 1e-6.\nadaptive::Bool: Whether the error control adaptivity is on, default as true.\ncontroller: Error controller for collocation methods, default as DefectControl(), more controller options in Error Control Adaptivity.\ndefect_threshold: Monitor of the size of defect norm. Defaults to 0.1.\nodesolve_kwargs: OrdinaryDiffEq.jl solvers kwargs for passing to ODE solving in shooting methods. For more information, see the documentation for OrdinaryDiffEq: Common Solver Options.\nnlsolve_kwargs: NonlinearSolve.jl solvers kwargs for passing to nonlinear solving in collocation methods and shooting methods. For more information, see the documentation for NonlinearSolve: Common Solver Options. The default internal nonlinear solver is customized polyalgorithm and the default absolute tolerance of nonlinear solving in collocation and shooting methods is 1e-6.\noptimize_kwargs: Optimization.jl solvers kwargs for passing to optimization problem solving in collocation methods and shooting methods. For more information, see the documentation for Optimization: Common Solver Options. The internal optimization solver should be specified and the default absolute tolerance of optimization problem solving in collocation and shooting methods is 1e-6.\nverbose:  Toggles whether warnings are thrown when the solver exits early. Defaults to true.\nensemblealg: Whether MultipleShooting uses multithreading, default as EnsembleThreads(). For more information, see the documentation for OrdinaryDiffEq: EnsembleAlgorithms.","category":"section"},{"location":"solvers/mirkn/#mirkn","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN","text":"Monotonic Implicit Runge Kutta Nyström(MIRKN) Methods. To only use the MIRKN methods form BoundaryValueDiffEq.jl, you need to install them use the Julia package manager:\n\nusing Pkg\nPkg.add(\"BoundaryValueDiffEqMIRKN\")\n\nsolve(prob::SecondOrderBVProblem, alg, dt; kwargs...)\nsolve(prob::TwoPointSecondOrderBVProblem, alg, dt; kwargs...)\n\nnote: Defect control adaptivity\nMIRKN don't have defect control adaptivity","category":"section"},{"location":"solvers/mirkn/#Full-List-of-Methods","page":"BoundaryValueDiffEqMIRKN","title":"Full List of Methods","text":"MIRKN4: 4 stage Monotonic Implicit Runge-Kutta-Nyström method, with no error control adaptivity.\nMIRKN6: 4 stage Monotonic Implicit Runge-Kutta-Nyström method, with no error control adaptivity.","category":"section"},{"location":"solvers/mirkn/#Detailed-Solvers-Explanation","page":"BoundaryValueDiffEqMIRKN","title":"Detailed Solvers Explanation","text":"","category":"section"},{"location":"solvers/mirkn/#BoundaryValueDiffEqMIRKN.MIRKN4","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN.MIRKN4","text":"MIRKN4(; nlsolve = NewtonRaphson(), optimize = nothing, jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n4th order Monotonic Implicit Runge Kutta Nyström method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used. Optimization solvers should first be loaded to allow this functionality.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Muir2001MonoImplicitRM,\n    title={Mono-Implicit Runge-Kutta-Nystr{\"o}m Methods with Application to Boundary Value Ordinary Differential Equations},\n    author={Paul H. Muir and Mark F. Adams},\n    journal={BIT Numerical Mathematics},\n    year={2001},\n    volume={41},\n    pages={776-799}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/mirkn/#BoundaryValueDiffEqMIRKN.MIRKN6","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN.MIRKN6","text":"MIRKN6(; nlsolve = NewtonRaphson(), optimize = nothing, jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n6th order Monotonic Implicit Runge Kutta Nyström method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used. Optimization solvers should first be loaded to allow this functionality.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Muir2001MonoImplicitRM,\n    title={Mono-Implicit Runge-Kutta-Nystr{\"o}m Methods with Application to Boundary Value Ordinary Differential Equations},\n    author={Paul H. Muir and Mark F. Adams},\n    journal={BIT Numerical Mathematics},\n    year={2001},\n    volume={41},\n    pages={776-799}\n}\n\n\n\n\n\n","category":"type"},{"location":"tutorials/optimal_control/#Solve-Dynamical-Optimization-problem","page":"Solve Dynamical Optimization problem","title":"Solve Dynamical Optimization problem","text":"BoundaryValueDiffEq.jl is capable of solving dynamical optimization problems via collocation solvers. The syntax for solving with BoundaryValueDiffEq.jl is quite different from JuMP-style optimization modeling DSL.\n\nTo model such optimal control problem is more similar to solve an boundary value problem, we only need to further provide the cost functional within BVPFunction. In the following content, we will explain the detailed usage of BoundaryValueDiffEq.jl in dynamical optimization with some hands-on examples.","category":"section"},{"location":"tutorials/optimal_control/#Block-Move-Optimal-Control","page":"Solve Dynamical Optimization problem","title":"Block Move Optimal Control","text":"Block move optimal control problem is an easy example of optimal control problem Kelly [5], this problem models moving a small block between two points, starting and finishing at rest, in a fixed amount of time.","category":"section"},{"location":"tutorials/optimal_control/#System-dynamics","page":"Solve Dynamical Optimization problem","title":"System dynamics","text":"Suppose we apply the external force f on a block which can slide without friction in one dimension, its position x and velocity v can be described using:\n\n$\n\n\\left{\\begin{aligned} &\\frac{dx}{dt}=v\\\n&\\frac{dv}{dt}=f \\end{aligned}\\right. $\n\nSince the presence of control variables f, we can pass our state variables and control variables together as [state variables, control variables], which is u = [x, v, f] in the system dynamics:\n\nfunction block_move!(du, u, p, t)\n    x, v, f = u[1], u[2], u[3]\n    du[1] = v\n    du[2] = f\nend\n\nTo tell solvers the difference between state variables and control variables, f_prototype must be explicitly specified in BVPFunction, for example, we have 2 state variables and 1 control variable, so f_prototype = zeros(2).","category":"section"},{"location":"tutorials/optimal_control/#Boundary-Constraints","page":"Solve Dynamical Optimization problem","title":"Boundary Constraints","text":"The block moves from x = -1 at time t = 0 to x = 0 at time t = 1, starting and finishing at rest:\n\n$\n\nx(0)=-1.0, v(0)=0, x(1)=0, v(1)=0 $\n\nSo the boundary conditions are:\n\nfunction block_move_bc!(res, u, p, t)\n    res[1] = u(0.0)[1] + 1.0\n    res[2] = u(0.0)[2]\n    res[3] = u(1.0)[1]\n    res[4] = u(1.0)[2]\nend","category":"section"},{"location":"tutorials/optimal_control/#Cost-functional","page":"Solve Dynamical Optimization problem","title":"Cost functional","text":"We want to minimize the total energy during the whole process, so the cost functional is an integral of the applied force(Lagrange form):\n\n$\n\n\\min{x(t),v(t),f(t)} \\frac{1}{2}\\int0^1 u^2(\\tau)d\\tau $\n\nThe cost functional should be defined following the interpolating style in boundary conditions, for example, use sol(t₁) to interpolate at t=t₁. Here, to express the integral cost function, we can directly use integral(f, domain) to integrate the integrand:\n\ncost_fun(sol, p) = 0.5*integral((t, p) -> sol(t)[3]^2, (0.0, 1.0))\n\nAs for other cost functional which need the interpolation of some exact points of the solution(Mayer form), we only need to define an OOP cost function that interpolating the solution at the specific point, for example:\n\ncost_fun(sol, p) = sol(1.0)[3]","category":"section"},{"location":"tutorials/optimal_control/#State-and-Control-bounds","page":"Solve Dynamical Optimization problem","title":"State and Control bounds","text":"Block move optimal control problem with minimized energy desn't require lower and upper bounds, so we can just specify lb = [-Inf, -Inf, -Inf] and ub = [Inf, Inf, Inf].","category":"section"},{"location":"tutorials/optimal_control/#Initial-guess","page":"Solve Dynamical Optimization problem","title":"Initial guess","text":"The initial guess of the dynamical optimization problem must be provided, either as the initial guess of the first state, u0 = [-1.0, 0.0, 6.0] or initial guess function of the whole solution such as u0(t, p) = [sin(t), cos(t), sin(t)].\n\nWith all the above parts, we can build the model for our block move optimal control example: So the copy-and-paste code for the block move optimal control problem is:\n\nusing BoundaryValueDiffEqMIRK, Ipopt, OptimizationMOI\n#cost_fun(sol, p) = 0.5*sum(reduce(hcat, sol.u)[3, :] .^ 2)*0.005\ncost_fun(sol, p) = 0.5*integral((t, p) -> sol(t)[3]^2, (0.0, 1.0))\nfunction block_move!(du, u, p, t)\n    x, v, f = u[1], u[2], u[3]\n    du[1] = v\n    du[2] = f\nend\nfunction block_move_bc!(res, u, p, t)\n    res[1] = u(0.0)[1] + 1.0\n    res[2] = u(0.0)[2]\n    res[3] = u(1.0)[1]\n    res[4] = u(1.0)[2]\nend\ntspan = (0.0, 1.0)\nu0 = [-1.0, 0.0, 6.0]\nblock_move_fun = BVPFunction(block_move!, block_move_bc!; cost = cost_fun,\n    f_prototype = zeros(2), bcresid_prototype = zeros(4))\nblock_move_prob = BVProblem(\n    block_move_fun, u0, tspan; lb = [-Inf, -Inf, -Inf], ub = [Inf, Inf, Inf])\nsol = solve(block_move_prob, MIRK4(; optimize = Ipopt.Optimizer()), dt = 0.002, adaptive = false)","category":"section"},{"location":"tutorials/optimal_control/#Rocket-Launching-Optimal-Control","page":"Solve Dynamical Optimization problem","title":"Rocket Launching Optimal Control","text":"Another classical optimal control problem is the rocket launching problem(aka Goddard Rocket problem). Say we have a rocket with limited fuel and is launched vertically. And we want to control the final altitude of this rocket so that we can make the best of the limited fuel in rocket to get to the highest altitude. In this optimal control problem, the state variables are:\n\nVelocity of the rocket: x_v(t)\nAltitude of the rocket: x_h(t)\nMass of the rocket and the fuel: x_m(t)\n\nThe control variable is\n\nThrust of the rocket: u_t(t)\n\nThe dynamics of the launching can be formulated with three differential equations:\n\n$\n\n\\left{\\begin{aligned} &\\frac{dxv}{dt}=\\frac{ut-drag(xh,xv)}{xm}-g(xh)\\\n&\\frac{dxh}{dt}=xv\\\n&\\frac{dxm}{dt}=-\\frac{ut}{c} \\end{aligned}\\right. $\n\nwhere the drag D(x_hx_v) is a function of altitude and velocity:\n\n$\n\nD(xh,xv)=Dc\\cdot xv^2\\cdot\\exp^{hc(\\frac{xh-xh(0)}{xh(0)})} $\n\ngravity g(x_h) is a function of altitude:\n\n$\n\ng(xh)=g0\\cdot (\\frac{xh(0)}{xh})^2 $\n\nc\n\nis a constant. Suppose the final time is T, we here want to maximize the final altitude x_h(T):\n\n$\n\n\\max x_h(T) $\n\nThe inequality constraints for the state variables and control variables are:\n\n$\n\n\\left{\\begin{aligned} &xv>0\\\n&xh>0\\\n&mT<xm<m0\\\n&0<ut<u_{t\\text{max}} \\end{aligned}\\right. $\n\nSimilar solving for such optimal control problem can be found on JuMP.jl and InfiniteOpt.jl. The detailed parameters are taken from COPS.\n\nusing BoundaryValueDiffEqMIRK, OptimizationIpopt, Plots\nh_0 = 1                      # Initial height\nv_0 = 0                      # Initial velocity\nm_0 = 1.0                    # Initial mass\nm_T = 0.6                    # Final mass\ng_0 = 1                      # Gravity at the surface\nh_c = 500                    # Used for drag\nc = 0.5 * sqrt(g_0 * h_0)    # Thrust-to-fuel mass\nD_c = 0.5 * 620 * m_0 / g_0  # Drag scaling\nu_t_max = 3.5 * g_0 * m_0    # Maximum thrust\nT_max = 0.2                  # Number of seconds\nT = 1_000                    # Number of time steps\nΔt = 0.2 / T;                # Time per discretized step\n\ntspan = (0.0, 0.2)\ndrag(x_h, x_v) = D_c * x_v^2 * exp(-h_c * (x_h - h_0) / h_0)\ng(x_h) = g_0 * (h_0 / x_h)^2\nfunction rocket_launch!(du, u, p, t)\n    # u_t is the control variable (thrust)\n    x_v, x_h, x_m, u_t = u[1], u[2], u[3], u[4]\n    du[1] = (u_t-drag(x_h, x_v))/x_m - g(x_h)\n    du[2] = x_v\n    du[3] = -u_t/c\nend\nfunction rocket_launch_bc!(res, u, p, t)\n    res[1] = u(0.0)[1] - v_0\n    res[2] = u(0.0)[2] - h_0\n    res[3] = u(0.0)[3] - m_0\n    res[4] = u(0.2)[4] - 0.0\nend\ncost_fun(u, p) = -u(0.2)[2]\nu0 = [v_0, h_0, m_T, 3.0]\nrocket_launch_fun = BVPFunction(rocket_launch!, rocket_launch_bc!; cost = cost_fun, f_prototype = zeros(3))\nrocket_launch_prob = BVProblem(\n    rocket_launch_fun, u0, tspan; lb = [0.0, h_0, m_T, 0.0], ub = [Inf, Inf, m_0, u_t_max])\nsol = solve(rocket_launch_prob, MIRK4(; optimize = Ipopt.Optimizer()); dt = Δt, adaptive = false)\n\nu = reduce(hcat, sol.u)\nv, h, m, c = u[1, :], u[2, :], u[3, :], u[4, :]\n\n# Plot the solution\np1 = plot(sol.t, v, xlabel = \"Time\", ylabel = \"Velocity\", legend = false)\np2 = plot(sol.t, h, xlabel = \"Time\", ylabel = \"Altitude\", legend = false)\np3 = plot(sol.t, m, xlabel = \"Time\", ylabel = \"Mass\", legend = false)\np4 = plot(sol.t, c, xlabel = \"Time\", ylabel = \"Thrust\", legend = false)\n\nplot(p1, p2, p3, p4, layout = (2, 2))\n\nSimilar optimal control problem solving can also be deployed in JuMP.jl and InfiniteOpt.jl.","category":"section"},{"location":"tutorials/optimal_control/#Cart-Pole-Optimal-Control","page":"Solve Dynamical Optimization problem","title":"Cart-Pole Optimal Control","text":"The dynamic equation of the motion of cart-pole swing-up problem are given by:\n\n$\n\n\\begin{bmatrix} \\ddot{x} \\\n\\ddot{\\theta} \\end{bmatrix}\n\n\\begin{bmatrix} \\cos\\theta & \\ell \\\nm1 + m2 & m_2 \\ell \\cos\\theta \\end{bmatrix}^{-1} \\begin{bmatrix}\n\ng \\sin\\theta \\\nF + m_2 \\ell \\dot{\\theta}^2 \\sin\\theta \\end{bmatrix} $\n\nwhere x is the location of the cart, theta is the pole angle, m_1 is the cart mass, m_2 is the pole mass, l is the pole length.\n\nBy converting the dynamics to first order equations, we can get the formulation:\n\n$\n\n\\begin{bmatrix} \\dot{x} \\\n\\dot{\\theta} \\\n\\ddot{x} \\\n\\ddot{\\theta} \\\n\\dot{e} \\end{bmatrix}\n\nf!\\left( \\begin{bmatrix} x \\ \\theta \\ \\dot{x} \\ \\dot{\\theta} \\ e \\end{bmatrix} \\right)\n\n\\begin{bmatrix} \\dot{x} \\\n\\dot{\\theta} \\\n\\dfrac{-m2 g \\sin\\theta \\cos\\theta - \\left(F + m2 \\ell \\dot{\\theta}^2 \\sin\\theta\\right)} {m2 \\cos^2\\theta - (m1 + m2)} \\\n\\dfrac{(m1 + m2) g \\sin\\theta + \\cos\\theta \\left(F + m2 \\ell \\dot{\\theta}^2 \\sin\\theta\\right)} {m2 \\ell \\cos^2\\theta - (m1 + m_2)\\ell} \\\nF^2 \\end{bmatrix} $\n\nand the initial conditions of all states at t=0 are all zero, the boundary conditions at time t_f are:\n\n$\n\nxf=d, \\dot{xf}=0, \\thetaf=\\pi, \\dot{\\thetaf}=0 $\n\nThe target cost function is defined as the \"energy\" so the target cost function is:\n\n$\n\n\\min J=\\int\\dot{e}dt=F $\n\nusing BoundaryValueDiffEqMIRK, OptimizationMOI, Ipopt, Plots\nm_1 = 1.0                      # Cart mass\nm_2 = 0.3                      # Pole mass\nl = 0.5                        # Pole length\nd = 2.0                        # Cart target location\nt_0 = 0.0                      # Start time\nt_f = 2.0                      # Final time\ng = 9.81                       # Gravity constant\ntspan = (t_0, t_f)\nfunction cart_pole!(du, u, p, t)\n    x, θ, dx, dθ, f = u[1], u[2], u[3], u[4], u[5]\n    du[1] = dx\n    du[2] = dθ\n    du[3] = (- m_2*g*sin(θ)*cos(θ) - (f + m_2*l*θ^2*sin(θ))) / (m_2*l*cos(θ)^2 - m_1 - m_2)\n    du[4] = ((m_1 + m_2)*g*sin(θ) + cos(θ)*(f + m_1*l*dθ^2*sin(θ))) /\n            (m_2*l*cos(θ)^2 - (m_1 + m_2)*l)\nend\n\nfunction cart_pole_bc!(du, u, p, t)\n    du[1] = u(t_f)[1] - d\n    du[2] = u(t_f)[2] - π\n    du[3] = u(t_0)[2] - 0.0\n    du[4] = u(t_0)[3] - 0.0\n    du[5] = u(t_0)[4] - 0.0\n    du[6] = u(t_f)[3] - 0.0\n    du[7] = u(t_f)[4] - 0.0\nend\ncost_fun(u, p) = u(t_f)[5]\nu0 = [0.0, 0.0, 0.0, 0.0, 10.0]\ncart_pole_fun = BVPFunction(cart_pole!, cart_pole_bc!; cost = cost_fun,\n    bcresid_prototype = zeros(7), f_prototype = zeros(4))\ncart_pole_prob = BVProblem(cart_pole_fun, u0, tspan; lb = [-2.0, -Inf, -Inf, -Inf, -20.0],\n    ub = [2.0, Inf, Inf, Inf, 20.0])\nsol = solve(cart_pole_prob, MIRK4(; optimize = Ipopt.Optimizer()); dt = 0.01, adaptive = false)\n\nt = sol.t\nx, theta, dx, dtheta, f = sol[1, :], sol[2, :], sol[3, :], sol[4, :], sol[5, :]\n\nL = 1.0    # pole length (visual)\ncart_w = 0.4    # cart width\ncart_h = 0.2    # cart height\n\n# Precompute pole tip coordinates\npx = x .+ L .* sin.(theta)\npy = cart_h/2 .- L .* cos.(theta)\n\n# Axis limits (a bit margin around the cart trajectory)\nxmin = minimum(x) - 2L\nxmax = maximum(x) + 2L\nymin = -2.0\nymax = 2.0\n\nanim = @animate for k in eachindex(t)\n    cart_x = x[k]\n    pole_x = px[k]\n    pole_y = py[k]\n\n    # Base plot / axis\n    plot(; xlim = (xmin, xmax), ylim = (ymin, ymax), aspect_ratio = :equal,\n        legend = false, title = \"Cart–Pole (t = $(round(t[k], digits=2)) s)\")\n\n    # Draw ground\n    plot!([xmin, xmax], [0, 0], lw = 2, color = :black)\n\n    # Draw cart as a rectangle\n    rect = Shape(\n        [cart_x - cart_w/2, cart_x + cart_w/2, cart_x + cart_w/2, cart_x - cart_w/2],\n        [0, 0, cart_h, cart_h])\n    plot!(rect, color = :gray)\n\n    # Draw pole as a line from cart center to tip\n    plot!([cart_x, pole_x], [cart_h/2, pole_y], lw = 3, color = :red)\n\n    # Draw pivot point\n    scatter!([cart_x], [cart_h/2], ms = 4, color = :black)\nend\n\n# Save GIF\ngif(anim, \"./cart_pole.gif\", fps = 40)\n\nAfter we plot the final solution:\n\n(Image: cart_pole)","category":"section"},{"location":"solvers/shooting/#shooting","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting","text":"Single shooting method and multiple shooting method. To only use the Shooting methods form BoundaryValueDiffEq.jl, you need to install them use the Julia package manager:\n\nusing Pkg\nPkg.add(\"BoundaryValueDiffEqShooting\")\n\nnote: Require OrdinaryDiffEq\nShooting methods require OrdinaryDiffEq.jl loaded to use the ODE solvers\n\nsolve(prob::BVProblem, alg; kwargs...)\nsolve(prob::TwoPointBVProblem, alg; kwargs...)\n\nShooting methods should be use together with ODE solvers:\n\nBoundaryValueDiffEqShooting.Shooting\nBoundaryValueDiffEqShooting.MultipleShooting","category":"section"},{"location":"solvers/shooting/#Full-List-of-Methods","page":"BoundaryValueDiffEqShooting","title":"Full List of Methods","text":"Shooting: Single shooting methods, reduces BVP to an initial value problem and solves the IVP.\nMultipleShooting: Reduces BVP to an initial value problem and solves the IVP. Significantly more stable than Single Shooting.","category":"section"},{"location":"solvers/shooting/#Detailed-Solvers-Explanation","page":"BoundaryValueDiffEqShooting","title":"Detailed Solvers Explanation","text":"","category":"section"},{"location":"solvers/shooting/#BoundaryValueDiffEqShooting.Shooting","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting.Shooting","text":"Shooting(ode_alg; kwargs...)\nShooting(ode_alg, nlsolve; kwargs...)\nShooting(; ode_alg = nothing, nlsolve = nothing, optimize = nothing, jac_alg = nothing)\n\nSingle shooting method, reduces BVP to an initial value problem and solves the IVP.\n\nArguments\n\node_alg: ODE algorithm to use for solving the IVP. Any solver which conforms to the SciML ODEProblem interface can be used! (Defaults to nothing which will use poly-algorithm if DifferentialEquations.jl is loaded else this must be supplied)\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the Nonlinear Solver. If this is not set, we check if nlsolve.ad exists and is not nothing. If it is, we use that to construct the jacobian. If not, we try to use the best algorithm based on the input types and problem type. If BVPJacobianAlgorithm is provided, only diffmode is used (defaults to AutoForwardDiff if possible else AutoFiniteDiff).\n\n\n\n\n\n","category":"type"},{"location":"solvers/shooting/#BoundaryValueDiffEqShooting.MultipleShooting","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting.MultipleShooting","text":"MultipleShooting(; nshoots::Int, ode_alg = nothing, nlsolve = nothing,\n    optimize = nothing, grid_coarsening = true, jac_alg = nothing)\nMultipleShooting(nshoots::Int; kwargs...)\nMultipleShooting(nshoots::Int, ode_alg; kwargs...)\nMultipleShooting(nshoots::Int, ode_alg, nlsolve; kwargs...)\n\nMultiple Shooting method, reduces BVP to an initial value problem and solves the IVP. Significantly more stable than Single Shooting.\n\nArguments\n\nnshoots: Number of shooting points.\node_alg: ODE algorithm to use for solving the IVP. Any solver which conforms to the SciML ODEProblem interface can be used! (Defaults to nothing which will use poly-algorithm if DifferentialEquations.jl is loaded else this must be supplied)\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used.\noptimize: Internal Optimization solver. Any solver which conforms to the SciML OptimizationProblem interface can be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode we default to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, we default to AutoForwardDiff if possible else AutoFiniteDiff.\ngrid_coarsening: Coarsening the multiple-shooting grid to generate a stable IVP solution. Possible Choices:\ntrue: Halve the grid size, till we reach a grid size of 1.\nfalse: Do not coarsen the grid. Solve a Multiple Shooting Problem and finally solve a Single Shooting Problem.\nAbstractVector{<:Int} or Ntuple{N, <:Integer}: Use the provided grid coarsening. For example, if nshoots = 10 and grid_coarsening = [5, 2], then the grid will be coarsened to [5, 2]. Note that 1 should not be present in the grid coarsening.\nFunction: Takes the current number of shooting points and returns the next number of shooting points. For example, if nshoots = 10 and grid_coarsening = n -> n ÷ 2, then the grid will be coarsened to [5, 2].\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_functions/#bvpfunctions","page":"BVP Functions and Jacobian Types","title":"BVP Functions and Jacobian Types","text":"The SciML ecosystem provides an extensive interface for declaring extra functions associated with the boundary value probems's data. In traditional libraries, there is usually only few options: the Jacobian and the Jacobian of boundary conditions. However, we allow for a large array of pre-computed functions to speed up the calculations. This is offered via the BVPFunction types, which can be passed to the problems.","category":"section"},{"location":"basics/bvp_functions/#Function-Type-Definitions","page":"BVP Functions and Jacobian Types","title":"Function Type Definitions","text":"","category":"section"},{"location":"basics/bvp_functions/#SciMLBase.BVPFunction","page":"BVP Functions and Jacobian Types","title":"SciMLBase.BVPFunction","text":"struct BVPFunction{iip, specialize, twopoint, F, BF, C, EC, IC, FP, TMM, Ta, Tt, TJ, BCTJ, JVP, VJP, JP, BCJP, BCRP, SP, TW, TWt, TPJ, O, TCV, BCTCV, SYS, ID} <: SciMLBase.AbstractBVPFunction{iip, twopoint}\n\nA representation of a BVP function f, defined by:\n\nfracdudt = f(u p t)\n\nand the constraints:\n\ng(u p t) = 0\n\nIf the size of g(u, p, t) is different from the size of u, then the constraints are interpreted as a least squares problem, i.e. the objective function is:\n\nmin_u  g_i(u p t) ^2\n\nand all of its related functions, such as the Jacobian of f, its gradient with respect to time, and more. For all cases, u0 is the initial condition, p are the parameters, and t is the independent variable.\n\nBVPFunction{iip, specialize}(f, bc;\n    cost = __has_cost(f) ? f.cost : nothing,\n    equality = __has_equality(f) ? f.equality : nothing,\n    inequality = __has_inequality(f) ? f.inequality : nothing,\n    f_prototype = __has_f_prototype(f) ? f.f_prototype : nothing,\n    mass_matrix = __has_mass_matrix(f) ? f.mass_matrix : I,\n    analytic = __has_analytic(f) ? f.analytic : nothing,\n    tgrad= __has_tgrad(f) ? f.tgrad : nothing,\n    jac = __has_jac(f) ? f.jac : nothing,\n    bcjac = __has_jac(bc) ? bc.jac : nothing,\n    jvp = __has_jvp(f) ? f.jvp : nothing,\n    vjp = __has_vjp(f) ? f.vjp : nothing,\n    jac_prototype = __has_jac_prototype(f) ? f.jac_prototype : nothing,\n    bcjac_prototype = __has_jac_prototype(bc) ? bc.jac_prototype : nothing,\n    sparsity = __has_sparsity(f) ? f.sparsity : jac_prototype,\n    paramjac = __has_paramjac(f) ? f.paramjac : nothing,\n    syms = nothing,\n    indepsym= nothing,\n    paramsyms = nothing,\n    colorvec = __has_colorvec(f) ? f.colorvec : nothing,\n    bccolorvec = __has_colorvec(f) ? bc.colorvec : nothing,\n    sys = __has_sys(f) ? f.sys : nothing,\n    twopoint::Union{Val, Bool} = Val(false))\n\nNote that both the function f and boundary condition bc are required. f should be given as f(du,u,p,t) or out = f(u,p,t). bc should be given as bc(res, u, p, t). See the section on iip for more details on in-place vs out-of-place handling.\n\nAll of the remaining functions are optional for improving or accelerating the usage of f and bc. These include:\n\ncost(u, p): the target to be minimized, similar with the cost function in OptimizationFunction. This is used to define the objective function of the BVP, which can be minimized by optimization solvers.\nequality(res, u, t): equality constraints functions for the BVP.\ninequality(res, u, t): inequality constraints functions for the BVP.\nf_prototype: a prototype matrix matching the type of the ODE/DAE variables in an optimal control problem. For example, in the ODE/DAE that describe the dynamics of the optiml control problem, f_prototype should match the type and size of the ODE/DAE variables in f.\nmass_matrix: the mass matrix M represented in the BVP function. Can be used to determine that the equation is actually a BVP for differential algebraic equation (DAE) if M is singular.\nanalytic(u0,p,t): used to pass an analytical solution function for the analytical solution of the BVP. Generally only used for testing and development of the solvers.\ntgrad(dT,u,h,p,t) or dT=tgrad(u,p,t): returns fracf(upt)t\njac(J,du,u,p,gamma,t) or J=jac(du,u,p,gamma,t): returns fracdfdu\nbcjac(J,du,u,p,gamma,t) or J=jac(du,u,p,gamma,t): returns fracdbcdu\njvp(Jv,v,du,u,p,gamma,t) or Jv=jvp(v,du,u,p,gamma,t): returns the directional derivative fracdfdu v\nvjp(Jv,v,du,u,p,gamma,t) or Jv=vjp(v,du,u,p,gamma,t): returns the adjoint derivative fracdfdu^ v\njac_prototype: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized Tridiagonal matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a SparseMatrixCSC with a correct sparsity pattern for the Jacobian. The default is nothing, which means a dense Jacobian.\nbcjac_prototype: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized Tridiagonal matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a SparseMatrixCSC with a correct sparsity pattern for the Jacobian. The default is nothing, which means a dense Jacobian.\nparamjac(pJ,u,p,t): returns the parameter Jacobian fracdfdp.\ncolorvec: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the jac_prototype. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to nothing, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.\nbccolorvec: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the bcjac_prototype. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to nothing, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.\n\nAdditional Options:\n\ntwopoint: Specify that the BVP is a two-point boundary value problem. Use Val(true) or Val(false) for type stability.\n\niip: In-Place vs Out-Of-Place\n\nFor more details on this argument, see the ODEFunction documentation.\n\nspecialize: Controlling Compilation and Specialization\n\nFor more details on this argument, see the ODEFunction documentation.\n\nFields\n\nThe fields of the BVPFunction type directly match the names of the inputs.\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_functions/#SciMLBase.DynamicalBVPFunction","page":"BVP Functions and Jacobian Types","title":"SciMLBase.DynamicalBVPFunction","text":"struct DynamicalBVPFunction{iip, specialize, twopoint, F, BF, C, EC, IC, FP, TMM, Ta, Tt, TJ, BCTJ, JVP, VJP, JP, BCJP, BCRP, SP, TW, TWt, TPJ, O, TCV, BCTCV, SYS, ID} <: SciMLBase.AbstractBVPFunction{iip, twopoint}\n\nA representation of a dynamical BVP function f, defined by:\n\nM u = f(uupt)\n\nalong with its boundary condition:\n\n\n\nand all of its related functions, such as the Jacobian of f, its gradient with respect to time, and more. For all cases, u0 is the initial condition, p are the parameters, and t is the independent variable.\n\nConstructor\n\nDynamicalBVPFunction{iip,specialize}(f, bc;\n                                    cost = __has_cost(f) ? f.cost : nothing,\n                                    equality = __has_equality(f) ? f.equality : nothing,\n                                    inequality = __has_inequality(f) ? f.inequality : nothing,\n                                    mass_matrix = __has_mass_matrix(f) ? f.mass_matrix : I,\n                                    analytic = __has_analytic(f) ? f.analytic : nothing,\n                                    tgrad= __has_tgrad(f) ? f.tgrad : nothing,\n                                    jac = __has_jac(f) ? f.jac : nothing,\n                                    jvp = __has_jvp(f) ? f.jvp : nothing,\n                                    vjp = __has_vjp(f) ? f.vjp : nothing,\n                                    jac_prototype = __has_jac_prototype(f) ? f.jac_prototype : nothing,\n                                    sparsity = __has_sparsity(f) ? f.sparsity : jac_prototype,\n                                    paramjac = __has_paramjac(f) ? f.paramjac : nothing,\n                                    colorvec = __has_colorvec(f) ? f.colorvec : nothing,\n                                    sys = __has_sys(f) ? f.sys : nothing\n                                    twopoint::Union{Val, Bool} = Val(false))\n\nNote that only the functions f_i themselves are required. These functions should be given as f_i!(du,du,u,p,t) or ddu = f_i(du,u,p,t). See the section on iip for more details on in-place vs out-of-place handling.\n\nAll of the remaining functions are optional for improving or accelerating the usage of f. These include:\n\ncost(du, u, p): the target to be minimized, similar with the cost function in OptimizationFunction. This is used to define the objective function of the BVP, which can be minimized by optimization solvers.\nequality(res, du, u, t): equality constraints functions for the BVP.\ninequality(res, du, u, t): inequality constraints functions for the BVP.\nf_prototype: a prototype matrix matching the type of the ODE/DAE variables in an optimal control problem. For example, in the ODE/DAE that describe the dynamics of the optiml control problem, f_prototype should match the type and size of the ODE/DAE variables in f.\nmass_matrix: the mass matrix M_i represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if M is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/. Must be an AbstractArray or an AbstractSciMLOperator. Should be given as a tuple of mass matrices, i.e. (M_1, M_2) for the mass matrices of equations 1 and 2 respectively.\nanalytic(u0,p,t): used to pass an analytical solution function for the analytical solution of the ODE. Generally only used for testing and development of the solvers.\ntgrad(dT,du,u,p,t) or dT=tgrad(du,u,p,t): returns fracf(duupt)t\njac(J,du,u,p,t) or J=jac(du,u,p,t): returns fracdfdu\njvp(Jv,v,u,p,t) or Jv=jvp(v,u,p,t): returns the directional derivative fracdfdu v\nvjp(Jv,v,u,p,t) or Jv=vjp(v,u,p,t): returns the adjoint derivative fracdfdu^ v\njac_prototype: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized Tridiagonal matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a SparseMatrixCSC with a correct sparsity pattern for the Jacobian. The default is nothing, which means a dense Jacobian.\nparamjac(pJ,du,u,p,t): returns the parameter Jacobian fracdfdp.\ncolorvec: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the jac_prototype. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to nothing, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.\n\niip: In-Place vs Out-Of-Place\n\nFor more details on this argument, see the ODEFunction documentation.\n\nspecialize: Controlling Compilation and Specialization\n\nFor more details on this argument, see the ODEFunction documentation.\n\nFields\n\nThe fields of the DynamicalBVPFunction type directly match the names of the inputs.\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_problem/#problems","page":"Boundary Value Problems","title":"Boundary Value Problems","text":"","category":"section"},{"location":"basics/bvp_problem/#The-Five-Types-of-Boundary-Value-Problems","page":"Boundary Value Problems","title":"The Five Types of Boundary Value Problems","text":"BoundaryValueDiffEq.jl tackles five related types of boundary value problems:\n\nGeneral boundary value problems:, i.e., constraints are applied over the time span. Both overconstraints and underconstraints BVP are supported.\nTwo-point boundary value problems:, i.e., constraints are only applied at start and end of time span. Both overconstraints and underconstraints BVP are supported.\nGeneral second order boundary value problems, i.e., constraints for both solution and derivative of solution are applied over time span. Both overconstraints and underconstraints second order BVP are supported.\nSecond order two-point boundary value problems, i.e., constraints for both solution and derivative of solution are only applied at the start and end of the time span. Both overconstraints and underconstraints second order BVP are supported.\nBoundary value differential algebraic equations, i.e., apart from constraints applied over the time span, BVDAE has additional algebraic equations which state the algebraic relationship of different states in BVDAE.","category":"section"},{"location":"basics/bvp_problem/#Problem-Construction-Details","page":"Boundary Value Problems","title":"Problem Construction Details","text":"","category":"section"},{"location":"basics/bvp_problem/#SciMLBase.BVProblem","page":"Boundary Value Problems","title":"SciMLBase.BVProblem","text":"Defines an BVP problem. Documentation Page: https://docs.sciml.ai/DiffEqDocs/stable/types/bvp_types/\n\nMathematical Specification of a BVP Problem\n\nTo define a BVP Problem, you simply need to give the function f and the initial condition u_0 which define an ODE:\n\nfracdudt = f(upt)\n\nalong with an implicit function bc which defines the residual equation, where\n\nbc(upt) = 0\n\nis the manifold on which the solution must live. A common form for this is the two-point BVProblem where the manifold defines the solution at two points:\n\nbeginalign*\nu(t_0) = a \nu(t_f) = b\nendalign*\n\nProblem Type\n\nConstructors\n\nTwoPointBVProblem{isinplace}(f, bc, u0, tspan, p=NullParameters(); kwargs...)\nBVProblem{isinplace}(f, bc, u0, tspan, p=NullParameters(); kwargs...)\n\nor if we have an initial guess function initialGuess(p, t) for the given BVP, we can pass the initial guess to the problem constructors:\n\nTwoPointBVProblem{isinplace}(f, bc, initialGuess, tspan, p=NullParameters(); kwargs...)\nBVProblem{isinplace}(f, bc, initialGuess, tspan, p=NullParameters(); kwargs...)\n\nFor any BVP problem type, bc must be inplace if f is inplace. Otherwise it must be out-of-place.\n\nIf the bvp is a StandardBVProblem (also known as a Multi-Point BV Problem) it must define either of the following functions\n\nbc!(residual, u, p, t)\nresidual = bc(u, p, t)\n\nwhere residual computed from the current u. u is an array of solution values where u[i] is at time t[i], while p are the parameters. For a TwoPointBVProblem, t = tspan. For the more general BVProblem, u can be all of the internal time points, and for shooting type methods u=sol the ODE solution. Note that all features of the ODESolution are present in this form. In both cases, the size of the residual matches the size of the initial condition.\n\nIf the bvp is a TwoPointBVProblem then bc must be a Tuple (bca, bcb) and each of them must define either of the following sets of functions:\n\nbca!(resid_a, u_a, p)\nbcb!(resid_b, u_b, p)\n\nor\n\nresid_a = bca(u_a, p)\nresid_b = bcb(u_b, p)\n\nwhere resid_a and resid_b are the residuals at the two endpoints, u_a and u_b are the solution values at the two endpoints, and p are the parameters.\n\nParameters are optional, and if not given, then a NullParameters() singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nFields\n\nf: The function for the ODE.\nbc: The boundary condition function.\nu0: The initial condition. Either the initial condition for the ODE as an initial value problem, or a Vector of values for u(t_i) for collocation methods.\ntspan: The timespan for the problem.\np: The parameters for the problem. Defaults to NullParameters.\nlb: The lower bounds for the solution variables. Defaults to nothing.\nub: The upper bounds for the solution variables. Defaults to nothing.\nlcons: The lower bounds for the constraint residuals. Defaults to nothing.\nucons: The upper bounds for the constraint residuals. Defaults to nothing.\nproblem_type: The type of the problem, either StandardBVProblem or TwoPointBVProblem.\nkwargs: The keyword arguments passed onto the solves.\n\nSpecial Keyword Arguments\n\nnlls: Specify that the BVP is a nonlinear least squares problem. Use Val(true) or Val(false) for type stability. By default this is automatically inferred based on the size of the input and outputs, however this is type unstable for any array type that doesn't store array size as part of type information. If we can't reliably infer this, we set it to Nothing. Downstreams solvers must be setup to deal with this case.\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_problem/#SciMLBase.TwoPointBVProblem","page":"Boundary Value Problems","title":"SciMLBase.TwoPointBVProblem","text":"struct TwoPointBVProblem{iip}\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_problem/#SciMLBase.SecondOrderBVProblem","page":"Boundary Value Problems","title":"SciMLBase.SecondOrderBVProblem","text":"Defines a second order BVP problem. Documentation Page: https://docs.sciml.ai/DiffEqDocs/stable/types/bvp_types/\n\nMathematical Specification of a second order BVP Problem\n\nTo define a second order BVP Problem, you simply need to give the function f and the initial condition u_0 which define an ODE:\n\nu = fracd^2 udt^2 = f(u u p t)\n\nalong with an implicit function bc which defines the residual equation, where\n\nbc(u u p t) = 0\n\nis the manifold on which the solution must live. A common form for this is the two-point SecondOrderBVProblem where the manifold defines the solution at two points:\n\nbeginalign*\ng(u(t_0) u(t_0)) = 0 \ng(u(t_f) u(t_f)) = 0\nendalign*\n\nProblem Type\n\nConstructors\n\nTwoPointSecondOrderBVProblem{isinplace}(f, bc, u0, tspan, p=NullParameters(); kwargs...)\nSecondOrderBVProblem{isinplace}(f, bc, u0, tspan, p=NullParameters(); kwargs...)\n\nor if we have an initial guess function initialGuess(p, t) for the given BVP, we can pass the initial guess to the problem constructors:\n\nTwoPointSecondOrderBVProblem{isinplace}(f, bc, initialGuess, tspan, p=NullParameters(); kwargs...)\nSecondOrderBVProblem{isinplace}(f, bc, initialGuess, tspan, p=NullParameters(); kwargs...)\n\nFor any BVP problem type, bc must be inplace if f is inplace. Otherwise it must be out-of-place.\n\nIf the bvp is a StandardSecondOrderBVProblem (also known as a Multi-Point BV Problem) it must define either of the following functions\n\nbc!(residual, du, u, p, t)\nresidual = bc(du, u, p, t)\n\nwhere residual computed from the current u. u is an array of solution values where u[i] is at time t[i], while p are the parameters. For a TwoPointBVProblem, t = tspan. For the more general BVProblem, u can be all of the internal time points, and for shooting type methods u=sol the ODE solution. Note that all features of the ODESolution are present in this form. In both cases, the size of the residual matches the size of the initial condition.\n\nIf the bvp is a TwoPointSecondOrderBVProblem then bc must be a Tuple (bca, bcb) and each of them must define either of the following sets of functions:\n\nbca!(resid_a, du_a, u_a, p)\nbcb!(resid_b, du_b, u_b, p)\n\nor\n\nresid_a = bca(du_a, u_a, p)\nresid_b = bcb(du_b, u_b, p)\n\nwhere resid_a and resid_b are the residuals at the two endpoints, u_a and u_b are the solution values at the two endpoints, du_a and du_b are the derivative of solution values at the two endpoints, and p are the parameters.\n\nParameters are optional, and if not given, then a NullParameters() singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nFields\n\nf: The function for the ODE.\nbc: The boundary condition function.\nu0: The initial condition. Either the initial condition for the ODE as an initial value problem, or a Vector of values for u(t_i) for collocation methods.\ntspan: The timespan for the problem.\np: The parameters for the problem. Defaults to NullParameters.\nlb: The lower bounds for the solution variables. Defaults to nothing.\nub: The upper bounds for the solution variables. Defaults to nothing.\nlcons: The lower bounds for the constraint residuals. Defaults to nothing.\nucons: The upper bounds for the constraint residuals. Defaults to nothing.\nproblem_type: The type of the problem, either StandardSecondOrderBVProblem or TwoPointSecondOrderBVProblem.\nkwargs: The keyword arguments passed onto the solves.\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_problem/#SciMLBase.TwoPointSecondOrderBVProblem","page":"Boundary Value Problems","title":"SciMLBase.TwoPointSecondOrderBVProblem","text":"struct TwoPointSecondOrderBVProblem{iip}\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#error_control","page":"Error Control Adaptivity","title":"Error Control Adaptivity","text":"Adaptivity helps ensure the quality of the our numerical solution, and when our solution exhibits significant estimating errors, adaptivity automatically refine the mesh based on the error distribution, and providing a final satisfying solution.\n\nWhen comes to solving ill-conditioned BVP, for example the singular perturbation problem where the small parameters become extremely small leading to the layers phonemona, the error control adaptivity becomes even more critical, because the minor perturbations can lead to large deviation in the solution. In such cases, adaptivity automatically figure out where to use refined mesh and where to use coarse mesh to achieve the balance of computational efficiency and accuracy.\n\nBoundaryValueDiffEq.jl support error control adaptivity for collocation methods, and the adaptivity is default as defect control adaptivity when using adaptive collocation solvers:\n\nsol = solve(prob, MIRK4(), dt = 0.01, adaptive = true)\n\nActually, BoundaryValueDiffEq.jl supports both defect and global error control adaptivity(while the defect control is the default controller) Boisvert et al. [4], to specify different error control methods, we simply need to specify the controller keyword in solve:\n\nsol = solve(prob, MIRK4(), dt = 0.01, controller = GlobalErrorControl()) # Use global error control\nsol = solve(prob, MIRK4(), dt = 0.01, controller = SequentialErrorControl()) # Use Sequential error control\nsol = solve(prob, MIRK4(), dt = 0.01, controller = HybridErrorControl()) # Use Hybrid error control","category":"section"},{"location":"basics/error_control/#Error-control-methods","page":"Error Control Adaptivity","title":"Error control methods","text":"While we can achieve global error control in different ways, we can use different methods to estimate the global error:","category":"section"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.DefectControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.DefectControl","text":"DefectControl(; defect_threshold = 0.1)\n\nDefect estimation method with defect defined as\n\ntextdefect = maxfracS(x) - f(xS(x))1 + f(xS(x))\n\nDefect controller, with the maximum defect_threshold as 0.1, when the estimating defect is greater than the defect_threshold, the mesh will be refined.\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.GlobalErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.GlobalErrorControl","text":"GlobalErrorControl(; method = HOErrorControl())\n\nGlobal error controller, use high order global error estimation method HOErrorControl as default.\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.SequentialErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.SequentialErrorControl","text":"SequentialErrorControl(; defect = DefectControl(), global_error = GlobalErrorControl())\n\nFirst use the defect controller, if the defect is satisfying, then use global error controller.\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.HybridErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.HybridErrorControl","text":"HybridErrorControl(; DE = 1.0, GE = 1.0, defect = DefectControl(), global_error = GlobalErrorControl())\n\nControl both of the defect and global error, where the error norm is the linear combination of the defect and global error.\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.NoErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.NoErrorControl","text":"NoErrorControl()\n\nNo error control method.\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.HOErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.HOErrorControl","text":"HOErrorControl()\n\nHigher order global error estimation method\n\nUses a solution from order+2 method on the original mesh and calculate the error with\n\ntexterror = maxfracu_p - u_p+21 + u_p\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.REErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.REErrorControl","text":"REErrorControl()\n\nRichardson extrapolation global error estimation method\n\nUse Richardson extrapolation to calculate the error on the doubled mesh with\n\ntexterror = frac2^p2^p-1  maxfracu_h - u_h21 + u_h\n\n\n\n\n\n","category":"type"},{"location":"solvers/simple_solvers/#simpleboundaryvaluediffeq","page":"SimpleBoundaryValueDiffEq","title":"SimpleBoundaryValueDiffEq","text":"","category":"section"},{"location":"solvers/simple_solvers/#Full-List-of-Methods","page":"SimpleBoundaryValueDiffEq","title":"Full List of Methods","text":"SimpleBoundaryValueDiffEq.SimpleMIRK4\nSimpleBoundaryValueDiffEq.SimpleMIRK5\nSimpleBoundaryValueDiffEq.SimpleMIRK6\nSimpleBoundaryValueDiffEq.SimpleShooting","category":"section"},{"location":"tutorials/getting_started/#Get-Started-with-Efficient-BVP-solving-in-Julia","page":"Getting Started with BVP solving in Julia","title":"Get Started with Efficient BVP solving in Julia","text":"When ordinary differential equations has constraints over the time span, we should model the differential equations as a boundary value problem which has the form of:\n\nfracdudt=f(u p t)\ng(u(a)u(b))=0\n\nBoundaryValueDiffEq.jl addresses three types of BVProblem.\n\nGeneral boundary value problems:, i.e., differential equations with constraints applied over the time span. This is a system where you would like to obtain the solution of the differential equations and make sure the solution satisfy the boundary conditions simutanously.\nGeneral second order boundary value problems, i.e., differential equations with constraints for both solution and derivative of solution applied over time span. This is a system where you would like to obtain the solution of the differential equations and make sure the solution satisfy the boundary conditions simutanously.\nBoundary value differential-algebraic equations, i.e., apart from constraints applied over the time span, BVDAE has additional algebraic equations which state the algebraic relationship of different states in BVDAE.","category":"section"},{"location":"tutorials/getting_started/#Solving-Linear-two-point-boundary-value-problem","page":"Getting Started with BVP solving in Julia","title":"Solving Linear two-point boundary value problem","text":"Consider the linear two-point boundary value problem from standard BVP test problem.\n\nusing BoundaryValueDiffEq\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = u[1]\nend\nfunction bc!(res, u, p, t)\n    res[1] = u(0.0)[1] - 1\n    res[2] = u(1.0)[1]\nend\ntspan = (0.0, 1.0)\nu0 = [0.0, 0.0]\nprob = BVProblem(f!, bc!, u0, tspan)\nsol = solve(prob, MIRK4(), dt = 0.01)\n\nSince this problem only has constraints at the start and end of the time span, we can directly use TwoPointBVProblem:\n\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = u[1]\nend\nfunction bca!(res, ua, p)\n    res[1] = ua[1] - 1\nend\nfunction bcb!(res, ub, p)\n    res[1] = ub[1]\nend\ntspan = (0.0, 1.0)\nu0 = [0.0, 0.0]\nprob = TwoPointBVProblem(\n    f!, (bca!, bcb!), u0, tspan, bcresid_prototype = (zeros(1), zeros(1)))\nsol = solve(prob, MIRK4(), dt = 0.01)","category":"section"},{"location":"tutorials/getting_started/#Solving-second-order-boundary-value-problem","page":"Getting Started with BVP solving in Julia","title":"Solving second order boundary value problem","text":"Consirder the test problem from example problems in MIRKN paper Muir and Adams [1].\n\nbegincases\ny_1(x) = y_2(x)\nε y_2(x) = -y_1(x) y_2(x) - y_3(x) y_3(x)\nε y_3(x) =  y_1(x) y_3(x) - y_1(x) y_3 (x)\nendcases\n\nwith initial conditions:\n\nbeginalign*\ny_1(0) = y_1(0) = y_1(1)=y_1(1)=0 \ny_3(0) = -1 \ny_3(1) =1\nendalign*\n\nusing BoundaryValueDiffEqMIRKN\nfunction f!(ddu, du, u, p, t)\n    ε = 0.1\n    ddu[1] = u[2]\n    ddu[2] = (-u[1] * du[2] - u[3] * du[3]) / ε\n    ddu[3] = (du[1] * u[3] - u[1] * du[3]) / ε\nend\nfunction bc!(res, du, u, p, t)\n    res[1] = u(0.0)[1]\n    res[2] = u(1.0)[1]\n    res[3] = u(0.0)[3] + 1\n    res[4] = u(1.0)[3] - 1\n    res[5] = du(0.0)[1]\n    res[6] = du(1.0)[1]\nend\nu0 = [1.0, 1.0, 1.0]\ntspan = (0.0, 1.0)\nprob = SecondOrderBVProblem(f!, bc!, u0, tspan)\nsol = solve(prob, MIRKN4(), dt = 0.01)","category":"section"},{"location":"tutorials/getting_started/#Solving-semi-explicit-boundary-value-differential-algebraic-equations","page":"Getting Started with BVP solving in Julia","title":"Solving semi-explicit boundary value differential-algebraic equations","text":"Consider the nonlinear semi-explicit DAE of index at most 2 in COLDAE paper Ascher and Spiteri [2]\n\nbegincases\nx_1 = (ε+ x_2 - sin(t)) y + cos(t) \nx_2 = cos(t) \nx_3 = y \n0 = (x_1-p_1(t)) (y-e^t)\nendcases\n\nwith boundary conditions\n\nbeginalign*\nx_1(0) = 0 \nx_3(0) = 1 \nx_2(1) = sin(1)\nendalign*\n\nusing BoundaryValueDiffEqAscher\nfunction f!(du, u, p, t)\n    du[1] = (1 + u[2] - sin(t)) * u[4] + cos(t)\n    du[2] = cos(t)\n    du[3] = u[4]\n    du[4] = (u[1] - sin(t)) * (u[4] - exp(t))\nend\nfunction bc!(res, u, p, t)\n    res[1] = u[1]\n    res[2] = u[3] - 1\n    res[3] = u[2] - sin(1.0)\nend\nu0 = [0.0, 0.0, 0.0, 0.0]\ntspan = (0.0, 1.0)\nfun = BVPFunction(f!, bc!, mass_matrix = [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 0])\nprob = BVProblem(fun, u0, tspan)\nsol = solve(prob, Ascher4(zeta = [0.0, 0.0, 1.0]), dt = 0.01)","category":"section"},{"location":"#BoundaryValueDiffEq.jl:-High-Performance-Boundary-Value-Problem-Solvers","page":"BoundaryValueDiffEq.jl: High-Performance Boundary Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Boundary Value Problem Solvers","text":"BoundaryValueDiffEq.jl is a component package in the DifferentialEquations.jl ecosystem. The package includes its own high-performance BVP solvers which covers wide range of different kinds boundary value problems, includes the ability to swap out to fast direct and iterative nonlinear solvers, along with the ability to use sparse automatic differentiation for Jacobian construction and Jacobian-vector products.","category":"section"},{"location":"#Installation","page":"BoundaryValueDiffEq.jl: High-Performance Boundary Value Problem Solvers","title":"Installation","text":"To install BoundaryValueDiffEq.jl, use the Julia package manager:\n\nusing Pkg\nPkg.add(\"BoundaryValueDiffEq\")","category":"section"},{"location":"#Contributing","page":"BoundaryValueDiffEq.jl: High-Performance Boundary Value Problem Solvers","title":"Contributing","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"section"},{"location":"#Reproducibility","page":"BoundaryValueDiffEq.jl: High-Performance Boundary Value Problem Solvers","title":"Reproducibility","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>\n\nusing Pkg # hide\nPkg.status() # hide\n\n</details>\n\n<details><summary>and using this machine and Julia version.</summary>\n\nusing InteractiveUtils # hide\nversioninfo() # hide\n\n</details>\n\n<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>\n\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" *\n                name *\n                \".jl/tree/gh-pages/v\" *\n                version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" *\n               name *\n               \".jl/tree/gh-pages/v\" *\n               version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"section"}]
}
