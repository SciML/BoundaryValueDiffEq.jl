var documenterSearchIndex = {"docs":
[{"location":"tutorials/continuation/#Solve-BVP-with-Continuation","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"","category":"section"},{"location":"tutorials/continuation/","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"Continuation is a commonly used technique for solving numerically difficult boundary value problems, we exploit the priori knowledge of the solution as initial guess to accelerate the BVP solving by breaking up the difficult BVP into a sequence of simpler problems. For example, we use the problem from Ascher et al. [3] in this tutorial:","category":"page"},{"location":"tutorials/continuation/","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"epsilon y + xy = epsilon pi^2cos(pi x) - pi xsin(pi x)","category":"page"},{"location":"tutorials/continuation/","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"for epsilon=10^-4, on tin-11 with two point boundary conditions y(-1)=-2 y(1)=0. With analitical solution of y(x)=cos(pi x)+texterf(fracxsqrt2epsilon)texterf(frac1sqrt2epsilon), this problem has a rapid transition layer at x=0, making it difficult to solve numerically. In this tutorial, we will showcase how to use continuation with BoundaryValueDiffEq.jl to solve this BVP.","category":"page"},{"location":"tutorials/continuation/","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"We use the substitution to transform this problem into a first order BVP system:","category":"page"},{"location":"tutorials/continuation/","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"y_1=y_2\ny_2= -fracxey_2 - pi^2cos(pi x) - fracpi xesin(pi x)","category":"page"},{"location":"tutorials/continuation/","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"Since this BVP would become difficult to solve when 0epsilonll 1, we start the continuation with relatively bigger epsilon to first obtain a good initial guess for cases when epsilon are becoming extremely small. We can just use the previous solution from BVP solving as the initial guess u0 when constructing a new BVProblem.","category":"page"},{"location":"tutorials/continuation/","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"using BoundaryValueDiffEq, Plots\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -t / p * u[2] - pi^2 * cos(pi * t) - pi * t / p * sin(pi * t)\nend\nfunction bc!(res, u, p, t)\n    res[1] = u[1][1] + 2\n    res[2] = u[end][1]\nend\ntspan = (-1.0, 1.0)\nsol = [1.0, 0.0]\ne = 0.1\nfor i in 2:4\n    global e = e / 10\n    prob = BVProblem(f!, bc!, sol, tspan, e)\n    global sol = solve(prob, MIRK4(), dt = 0.01)\nend\nplot(sol, idxs = [1])","category":"page"},{"location":"tutorials/continuation/","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"In the iterative solving, the intermediate solutions are each used as the initial guess for the next problem solving.","category":"page"},{"location":"tutorials/continuation/#On-providing-initial-guess","page":"Solve BVP with Continuation","title":"On providing initial guess","text":"","category":"section"},{"location":"tutorials/continuation/","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"There are several ways of providing initial guess in BVProblem/TwoPointBVProblem:","category":"page"},{"location":"tutorials/continuation/","page":"Solve BVP with Continuation","title":"Solve BVP with Continuation","text":"Solution from BVP/ODE solving from SciML packages with ODESolution type.\nVectorOfArray from RecursiveArrayTools.jl.\nDiffEqArray from RecursiveArrayTools.jl.\nFunction handle of the form f(p, t) for specifying initial guess on time span.\nAbstractArray represent only the possible initial condition.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"P. H. Muir and M. F. Adams. Mono-Implicit Runge-Kutta-Nyström Methods with Application to Boundary Value Ordinary Differential Equations. BIT Numerical Mathematics 41, 776–799 (2001).\n\n\n\nU. M. Ascher and R. J. Spiteri. Collocation software for boundary value differential-algebraic equations. SIAM Journal on Scientific Computing 15, 938–952 (1994).\n\n\n\nU. M. Ascher, R. M. Mattheij and R. D. Russell. Numerical Solution of Boundary Value Problems for Ordinary Differential Equations (Society for Industrial and Applied Mathematics, 1995), arXiv:https://epubs.siam.org/doi/pdf/10.1137/1.9781611971231.\n\n\n\nJ. J. Boisvert, P. H. Muir and R. J. Spiteri. A Runge-Kutta BVODE solver with global error and defect control. ACM Transactions on Mathematical Software (TOMS) 39, 1–22 (2013).\n\n\n\n","category":"page"},{"location":"tutorials/extremum/#Solve-BVP-with-Extremum-Boundary-Conditions","page":"Solve BVP with Extremum Boundary Conditions","title":"Solve BVP with Extremum Boundary Conditions","text":"","category":"section"},{"location":"tutorials/extremum/","page":"Solve BVP with Extremum Boundary Conditions","title":"Solve BVP with Extremum Boundary Conditions","text":"In many physical systems, boundary conditions are not always defined at fixed points such as intitial or terminal ends of the domain. Instead, we may encounter scenarios where constraints are imposed on the maximum or minimum values that the solution must attain somewhere within the domain. In such cases, we can use the maxsol and minsol functions provided by BoundaryValueDiffEq.jl to specify such extremum boundary conditions.","category":"page"},{"location":"tutorials/extremum/","page":"Solve BVP with Extremum Boundary Conditions","title":"Solve BVP with Extremum Boundary Conditions","text":"Let's walk through this functionality with an intuitive example. We still revisit the simple pendulum example here, but this time, suppose we need to impose the maximum and minimum value to our boundary conditions, specified as:","category":"page"},{"location":"tutorials/extremum/","page":"Solve BVP with Extremum Boundary Conditions","title":"Solve BVP with Extremum Boundary Conditions","text":"maxu=ub\nminu=lb","category":"page"},{"location":"tutorials/extremum/","page":"Solve BVP with Extremum Boundary Conditions","title":"Solve BVP with Extremum Boundary Conditions","text":"where lb=-4.8161991710010925 and ub=5.0496477654230745. So the states must conform that the maximum value of the state should be lb while the minimum value of the state should be ub. To solve such problems, we can simply use the maxsol and minsol functions when defining the boundary value problem in BoundaryValueDiffEq.jl.","category":"page"},{"location":"tutorials/extremum/","page":"Solve BVP with Extremum Boundary Conditions","title":"Solve BVP with Extremum Boundary Conditions","text":"using BoundaryValueDiffEq, Plots\ntspan = (0.0, pi / 2)\nfunction simplependulum!(du, u, p, t)\n    θ = u[1]\n    dθ = u[2]\n    du[1] = dθ\n    du[2] = -9.81 * sin(θ)\nend\nfunction bc!(residual, u, p, t)\n    residual[1] = maxsol(u, (0.0, pi / 2)) - 5.0496477654230745\n    residual[2] = minsol(u, (0.0, pi / 2)) + 4.8161991710010925\nend\nprob = BVProblem(simplependulum!, bc!, [pi / 2, pi / 2], tspan)\nsol = solve(prob, MIRK4(), dt = 0.05)\nplot(sol)","category":"page"},{"location":"solvers/mirk/#mirk","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK","text":"","category":"section"},{"location":"solvers/mirk/","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK","text":"Monotonic Implicit Runge Kutta(MIRK) Methods. To only use the MIRK methods form BoundaryVaueDiffEq.jl, you need to install them use the Julia package manager:","category":"page"},{"location":"solvers/mirk/","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK","text":"using Pkg\nPkg.add(\"BoundaryValueDiffEqFIRK\")","category":"page"},{"location":"solvers/mirk/","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK","text":"solve(prob::BVProblem, alg, dt; kwargs...)\nsolve(prob::TwoPointBVProblem, alg, dt; kwargs...)","category":"page"},{"location":"solvers/mirk/#Full-List-of-Methods","page":"BoundaryValueDiffEqMIRK","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/mirk/","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK","text":"MIRK2: 2 stage Monotonic Implicit Runge-Kutta method, with defect control adaptivity.\nMIRK3: 3 stage Monotonic Implicit Runge-Kutta method, with defect control adaptivity.\nMIRK4: 4 stage Monotonic Implicit Runge-Kutta method, with defect control adaptivity.\nMIRK5: 5 stage Monotonic Implicit Runge-Kutta method, with defect control adaptivity.\nMIRK6: 6 stage Monotonic Implicit Runge-Kutta method, with defect control adaptivity.","category":"page"},{"location":"solvers/mirk/#Detailed-Solvers-Explanation","page":"BoundaryValueDiffEqMIRK","title":"Detailed Solvers Explanation","text":"","category":"section"},{"location":"solvers/mirk/#BoundaryValueDiffEqMIRK.MIRK2","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK.MIRK2","text":"MIRK2(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n2th order Monotonic Implicit Runge Kutta method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Enright1996RungeKuttaSW,\n    title={Runge-Kutta Software with Defect Control for Boundary Value ODEs},\n    author={Wayne H. Enright and Paul H. Muir},\n    journal={SIAM J. Sci. Comput.},\n    year={1996},\n    volume={17},\n    pages={479-497}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/mirk/#BoundaryValueDiffEqMIRK.MIRK3","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK.MIRK3","text":"MIRK3(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n3th order Monotonic Implicit Runge Kutta method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Enright1996RungeKuttaSW,\n    title={Runge-Kutta Software with Defect Control for Boundary Value ODEs},\n    author={Wayne H. Enright and Paul H. Muir},\n    journal={SIAM J. Sci. Comput.},\n    year={1996},\n    volume={17},\n    pages={479-497}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/mirk/#BoundaryValueDiffEqMIRK.MIRK4","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK.MIRK4","text":"MIRK4(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n4th order Monotonic Implicit Runge Kutta method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Enright1996RungeKuttaSW,\n    title={Runge-Kutta Software with Defect Control for Boundary Value ODEs},\n    author={Wayne H. Enright and Paul H. Muir},\n    journal={SIAM J. Sci. Comput.},\n    year={1996},\n    volume={17},\n    pages={479-497}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/mirk/#BoundaryValueDiffEqMIRK.MIRK5","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK.MIRK5","text":"MIRK5(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n5th order Monotonic Implicit Runge Kutta method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Enright1996RungeKuttaSW,\n    title={Runge-Kutta Software with Defect Control for Boundary Value ODEs},\n    author={Wayne H. Enright and Paul H. Muir},\n    journal={SIAM J. Sci. Comput.},\n    year={1996},\n    volume={17},\n    pages={479-497}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/mirk/#BoundaryValueDiffEqMIRK.MIRK6","page":"BoundaryValueDiffEqMIRK","title":"BoundaryValueDiffEqMIRK.MIRK6","text":"MIRK6(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n        defect_threshold = 0.1, max_num_subintervals = 3000)\n\n6th order Monotonic Implicit Runge Kutta method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Enright1996RungeKuttaSW,\n    title={Runge-Kutta Software with Defect Control for Boundary Value ODEs},\n    author={Wayne H. Enright and Paul H. Muir},\n    journal={SIAM J. Sci. Comput.},\n    year={1996},\n    volume={17},\n    pages={479-497}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/wrappers/#wrapper","page":"Wrapper Methods","title":"Wrapper Methods","text":"","category":"section"},{"location":"solvers/wrappers/","page":"Wrapper Methods","title":"Wrapper Methods","text":"note: Require ODEInterface\nWrapper methods require ODEInterface.jl loaded","category":"page"},{"location":"solvers/wrappers/","page":"Wrapper Methods","title":"Wrapper Methods","text":"solve(prob::BVProblem, alg; kwargs...)\nsolve(prob::TwoPointBVProblem, alg; kwargs...)","category":"page"},{"location":"solvers/wrappers/#Full-List-of-Methods","page":"Wrapper Methods","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/wrappers/","page":"Wrapper Methods","title":"Wrapper Methods","text":"BVPM2: Single shooting methods, reduces BVP to an initial value problem and solves the IVP.\nBVPSOL: Reduces BVP to an initial value problem and solves the IVP. Significantly more stable than Single Shooting.\nCOLNEW: Gauss-Legendre collocation methods for BVP with Ascher's error control adaptivity and mesh refinement.","category":"page"},{"location":"api/odeinterface/#ODEInterface.jl","page":"ODEInterface.jl","title":"ODEInterface.jl","text":"","category":"section"},{"location":"api/odeinterface/","page":"ODEInterface.jl","title":"ODEInterface.jl","text":"This is an extension for importing solvers from ODEInterface.jl into the SciML interface. Note that these solvers do not come by default, and thus one needs to install the package before using these solvers:","category":"page"},{"location":"api/odeinterface/","page":"ODEInterface.jl","title":"ODEInterface.jl","text":"using Pkg\nPkg.add(\"ODEInterface\")\nusing ODEInterface, BoundaryValueDiffEq","category":"page"},{"location":"api/odeinterface/#Solver-API","page":"ODEInterface.jl","title":"Solver API","text":"","category":"section"},{"location":"api/odeinterface/#BoundaryValueDiffEq.BVPM2","page":"ODEInterface.jl","title":"BoundaryValueDiffEq.BVPM2","text":"BVPM2(; max_num_subintervals = 3000, method_choice = 4, diagnostic_output = 1,\n    error_control = 1, singular_term = nothing)\nBVPM2(max_num_subintervals::Int, method_choice::Int, diagnostic_output::Int,\n    error_control::Int, singular_term)\n\nFortran code for solving two-point boundary value problems. For detailed documentation, see ODEInterface.jl.\n\nKeyword Arguments:\n\n- `max_num_subintervals`: Number of maximal subintervals, default as 3000.\n- `method_choice`: Choice for IVP-solvers, default as Runge-Kutta method of order 4,\n  available choices:\n    - `2`: Runge-Kutta method of order 2.\n    - `4`: Runge-Kutta method of order 4.\n    - `6`: Runge-Kutta method of order 6.\n- `diagnostic_output`: Diagnostic output for BVPM2, default as non printout, available\n  choices:\n    - `-1`: Full diagnostic printout.\n    - `0`: Selected printout.\n    - `1`: No printout.\n- `error_control`: Determines the error-estimation for which RTOL is used, default as\n  defect control, available choices:\n    - `1`: Defect control.\n    - `2`: Global error control.\n    - `3`: Defect and then global error control.\n    - `4`: Linear combination of defect and global error control.\n- `singular_term`: either nothing if the ODEs have no singular terms at the left\n  boundary or a constant (d,d) matrix for the\n    singular term.\n\nnote: Note\nOnly available if the ODEInterface package is loaded.\n\n\n\n\n\n","category":"type"},{"location":"api/odeinterface/#BoundaryValueDiffEq.BVPSOL","page":"ODEInterface.jl","title":"BoundaryValueDiffEq.BVPSOL","text":"BVPSOL(; bvpclass = 2, sol_method = 0, odesolver = nothing)\nBVPSOL(bvpclass::Int, sol_methods::Int, odesolver)\n\nA FORTRAN77 code which solves highly nonlinear two point boundary value problems using a local linear solver (condensing algorithm) or a global sparse linear solver for the solution of the arising linear subproblems, by Peter Deuflhard, Georg Bader, Lutz Weimann. For detailed documentation, see ODEInterface.jl.\n\nKeyword Arguments\n\n- `bvpclass`: Boundary value problem classification, default as highly nonlinear with\n  bad initial data, available choices:\n    - `0`: Linear boundary value problem.\n    - `1`: Nonlinear with good initial data.\n    - `2`: Highly Nonlinear with bad initial data.\n    - `3`: Highly nonlinear with bad initial data and initial rank reduction to\n      seperable linear boundary conditions.\n- `sol_method`: Switch for solution methods, default as local linear solver with\n  condensing algorithm, available choices:\n    - `0`: Use local linear solver with condensing algorithm.\n    - `1`: Use global sparse linear solver.\n- `odesolver`: Either `nothing` or ode-solver(dopri5, dop853, seulex, etc.).\n\nnote: Note\nOnly available if the ODEInterface package is loaded.\n\n\n\n\n\n","category":"type"},{"location":"api/odeinterface/#BoundaryValueDiffEq.COLNEW","page":"ODEInterface.jl","title":"BoundaryValueDiffEq.COLNEW","text":"COLNEW(; bvpclass = 1, collocationpts = 7, diagnostic_output = 1,\n    max_num_subintervals = 3000, bc_func = nothing, dbc_func = nothing,\n    zeta = nothing)\nCOLNEW(bvpclass::Int, collocationpts::Int, diagnostic_output::Int,\n    max_num_subintervals::Int, bc_func, dbc_func, zeta::AbstractVector)\n\nKeyword Arguments:\n\nbvpclass: Boundary value problem classification, default as nonlinear and \"extra sensitive\", available choices:\n0: Linear boundary value problem.\n1: Nonlinear and regular.\n2: Nonlinear and \"extra sensitive\" (first relax factor is rstart and the nonlinear iteration does not rely on past convergence).\n3: fail-early: return immediately upon: a) two successive non-convergences. b) after obtaining an error estimate for the first time.\ncollocationpts: Number of collocation points per subinterval. Require orders[i] ≤ k ≤ 7, default as 7\ndiagnostic_output: Diagnostic output for COLNEW, default as no printout, available choices:\n-1: Full diagnostic printout.\n0: Selected printout.\n1: No printout.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nbc_func: Boundary condition accord with ODEInterface.jl, only used for multi-points BVP.\ndbc_func: Jacobian of boundary condition accord with ODEInterface.jl, only used for multi-points BVP.\nzeta: The points in interval where boundary conditions are specified, only used for multi-points BVP.\n\nA Fortran77 code solves a multi-points boundary value problems for a mixed order system of ODEs. It incorporates a new basis representation replacing b-splines, and improvements for the linear and nonlinear algebraic equation solvers.\n\nwarning: Warning\nOnly supports two-point boundary value problems.\n\nnote: Note\nOnly available if the ODEInterface package is loaded.\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#firk","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"","category":"section"},{"location":"solvers/firk/","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"Fully Implicit Runge Kutta(FIRK) Methods. To be able to access the solvers in BoundaryValueDiffEqFIRK, you must first install them use the Julia package manager:","category":"page"},{"location":"solvers/firk/","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"using Pkg\nPkg.add(\"BoundaryValueDiffEqFIRK\")","category":"page"},{"location":"solvers/firk/","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"solve(prob::BVProblem, alg, dt; kwargs...)\nsolve(prob::TwoPointBVProblem, alg, dt; kwargs...)","category":"page"},{"location":"solvers/firk/#Nested-nonlinear-solving-in-FIRK-methods","page":"BoundaryValueDiffEqFIRK","title":"Nested nonlinear solving in FIRK methods","text":"","category":"section"},{"location":"solvers/firk/","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"When working with large boundary value problems, especially those involving stiff systems, computational efficiency and solver robustness become critical concerns. To improve the efficiency of FIRK methods on large BVPs, we can use nested nonlinear solving to obtain the implicit FIRK step instead of solving them as part of the global residual. In BoundaryValueDiffEq.jl, we can set nested_nlsolve as true to enable FIRK methods to compute the implicit FIRK steps using nested nonlinear solving(default option in FIRK methods is nested_nlsolve=false).","category":"page"},{"location":"solvers/firk/","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"Moreover, the nested nonlinear problem solver can be finely tuned to meet specific accuracy requirements by providing detailed keyword arguments through the nested_nlsolve_kwargs option in any FIRK solver, for example, RadauIIa5(; nested_nlsolve = true, nested_nlsolve_kwargs = (; abstol = 1e-6, reltol = 1e-6)), where nested_nlsolve_kwargs can be any common keyword arguments in NonlinearSolve.jl, see Common Solver Options in NonlinearSolve.jl.","category":"page"},{"location":"solvers/firk/#Full-List-of-Methods","page":"BoundaryValueDiffEqFIRK","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/firk/#Radau-IIA-methods","page":"BoundaryValueDiffEqFIRK","title":"Radau IIA methods","text":"","category":"section"},{"location":"solvers/firk/","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"RadauIIa1: 1 stage Radau IIA method, without defect control adaptivity\nRadauIIa2: 2 stage Radau IIA method, with defect control adaptivity.\nRadauIIa3: 3 stage Radau IIA method, with defect control adaptivity.\nRadauIIa5: 5 stage Radau IIA method, with defect control adaptivity.\nRadauIIa7: 7 stage Radau IIA method, with defect control adaptivity.","category":"page"},{"location":"solvers/firk/#Lobatto-IIIA-methods","page":"BoundaryValueDiffEqFIRK","title":"Lobatto IIIA methods","text":"","category":"section"},{"location":"solvers/firk/","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"LobattoIIIa2: 2 stage Lobatto IIIa method, with defect control adaptivity.\nLobattoIIIa3: 3 stage Lobatto IIIa method, with defect control adaptivity.\nLobattoIIIa4: 4 stage Lobatto IIIa method, with defect control adaptivity.\nLobattoIIIa5: 5 stage Lobatto IIIa method, with defect control adaptivity.","category":"page"},{"location":"solvers/firk/#Lobatto-IIIB-methods","page":"BoundaryValueDiffEqFIRK","title":"Lobatto IIIB methods","text":"","category":"section"},{"location":"solvers/firk/","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"LobattoIIIb2: 2 stage Lobatto IIIb method, without defect control adaptivity.\nLobattoIIIb3: 3 stage Lobatto IIIb method, with defect control adaptivity.\nLobattoIIIb4: 4 stage Lobatto IIIb method, with defect control adaptivity.\nLobattoIIIb5: 5 stage Lobatto IIIb method, with defect control adaptivity.","category":"page"},{"location":"solvers/firk/#Lobatto-IIIC-methods","page":"BoundaryValueDiffEqFIRK","title":"Lobatto IIIC methods","text":"","category":"section"},{"location":"solvers/firk/","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK","text":"LobattoIIIc2: 2 stage Lobatto IIIc method, without defect control adaptivity.\nLobattoIIIc3: 3 stage Lobatto IIIc method, with defect control adaptivity.\nLobattoIIIc4: 4 stage Lobatto IIIc method, with defect control adaptivity.\nLobattoIIIc5: 5 stage Lobatto IIIc method, with defect control adaptivity.","category":"page"},{"location":"solvers/firk/#Detailed-Solvers-Explanation","page":"BoundaryValueDiffEqFIRK","title":"Detailed Solvers Explanation","text":"","category":"section"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.RadauIIa1","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.RadauIIa1","text":"  RadauIIa1(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n1th stage RadauIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@incollection{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    editor={Engquist, Bj{\"o}rn},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.RadauIIa2","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.RadauIIa2","text":"  RadauIIa2(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n2th stage RadauIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@incollection{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    editor={Engquist, Bj{\"o}rn},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.RadauIIa3","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.RadauIIa3","text":"  RadauIIa3(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n3th stage RadauIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@incollection{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    editor={Engquist, Bj{\"o}rn},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.RadauIIa5","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.RadauIIa5","text":"  RadauIIa5(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n5th stage RadauIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@incollection{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    editor={Engquist, Bj{\"o}rn},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.RadauIIa7","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.RadauIIa7","text":"  RadauIIa7(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n7th stage RadauIIa method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@incollection{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    editor={Engquist, Bj{\"o}rn},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIa2","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIa2","text":"  LobattoIIIa2(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n2th stage LobattoIIIa method.\n\nKeyword Arguments\n\n- `nlsolve`: Internal Nonlinear solver. Any solver which conforms to the SciML\n`NonlinearProblem` interface can be used. Note that any autodiff argument for\n  the solver will be ignored and a custom jacobian algorithm will be used.\n\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n  Reference for Lobatto and Radau methods:\n  ```bibtex\n      @Inbook{Jay2015,\n      author=\"Jay, Laurent O.\",\n      editor=\"Engquist, Bj{\"o}rn\",\n      title=\"Lobatto Methods\",\n      booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n      year=\"2015\",\n      publisher=\"Springer Berlin Heidelberg\",\n      }\n      @incollection{engquist_radau_2015,\n      author = {Hairer, Ernst and Wanner, Gerhard},\n      title = {Radau {Methods}},\n      booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n      publisher = {Springer Berlin Heidelberg},\n      editor=\"Engquist, Bj{\"o}rn\",\n      year = {2015},\n  }\n  ```\n  References for implementation of defect control, based on the `bvp5c` solver in MATLAB:\n  ```bibtex\n  @article{shampine_solving_nodate,\n  title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n  author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n  year = {2000},\n  }\n\n  @article{kierzenka_bvp_2008,\n      title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n      author = {Kierzenka, J and Shampine, L F},\n      year = {2008},\n  }\n\n  @article{russell_adaptive_1978,\n      title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n      journal = {SIAM Journal on Numerical Analysis},\n      author = {Russell, R. D. and Christiansen, J.},\n      year = {1978},\n      file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n  }\n  ```\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIa3","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIa3","text":"  LobattoIIIa3(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n3th stage LobattoIIIa method.\n\nKeyword Arguments\n\n- `nlsolve`: Internal Nonlinear solver. Any solver which conforms to the SciML\n`NonlinearProblem` interface can be used. Note that any autodiff argument for\n  the solver will be ignored and a custom jacobian algorithm will be used.\n\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n  Reference for Lobatto and Radau methods:\n  ```bibtex\n      @Inbook{Jay2015,\n      author=\"Jay, Laurent O.\",\n      editor=\"Engquist, Bj{\"o}rn\",\n      title=\"Lobatto Methods\",\n      booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n      year=\"2015\",\n      publisher=\"Springer Berlin Heidelberg\",\n      }\n      @incollection{engquist_radau_2015,\n      author = {Hairer, Ernst and Wanner, Gerhard},\n      title = {Radau {Methods}},\n      booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n      publisher = {Springer Berlin Heidelberg},\n      editor=\"Engquist, Bj{\"o}rn\",\n      year = {2015},\n  }\n  ```\n  References for implementation of defect control, based on the `bvp5c` solver in MATLAB:\n  ```bibtex\n  @article{shampine_solving_nodate,\n  title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n  author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n  year = {2000},\n  }\n\n  @article{kierzenka_bvp_2008,\n      title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n      author = {Kierzenka, J and Shampine, L F},\n      year = {2008},\n  }\n\n  @article{russell_adaptive_1978,\n      title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n      journal = {SIAM Journal on Numerical Analysis},\n      author = {Russell, R. D. and Christiansen, J.},\n      year = {1978},\n      file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n  }\n  ```\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIa4","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIa4","text":"  LobattoIIIa4(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n4th stage LobattoIIIa method.\n\nKeyword Arguments\n\n- `nlsolve`: Internal Nonlinear solver. Any solver which conforms to the SciML\n`NonlinearProblem` interface can be used. Note that any autodiff argument for\n  the solver will be ignored and a custom jacobian algorithm will be used.\n\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n  Reference for Lobatto and Radau methods:\n  ```bibtex\n      @Inbook{Jay2015,\n      author=\"Jay, Laurent O.\",\n      editor=\"Engquist, Bj{\"o}rn\",\n      title=\"Lobatto Methods\",\n      booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n      year=\"2015\",\n      publisher=\"Springer Berlin Heidelberg\",\n      }\n      @incollection{engquist_radau_2015,\n      author = {Hairer, Ernst and Wanner, Gerhard},\n      title = {Radau {Methods}},\n      booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n      publisher = {Springer Berlin Heidelberg},\n      editor=\"Engquist, Bj{\"o}rn\",\n      year = {2015},\n  }\n  ```\n  References for implementation of defect control, based on the `bvp5c` solver in MATLAB:\n  ```bibtex\n  @article{shampine_solving_nodate,\n  title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n  author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n  year = {2000},\n  }\n\n  @article{kierzenka_bvp_2008,\n      title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n      author = {Kierzenka, J and Shampine, L F},\n      year = {2008},\n  }\n\n  @article{russell_adaptive_1978,\n      title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n      journal = {SIAM Journal on Numerical Analysis},\n      author = {Russell, R. D. and Christiansen, J.},\n      year = {1978},\n      file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n  }\n  ```\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIa5","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIa5","text":"  LobattoIIIa5(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n5th stage LobattoIIIa method.\n\nKeyword Arguments\n\n- `nlsolve`: Internal Nonlinear solver. Any solver which conforms to the SciML\n`NonlinearProblem` interface can be used. Note that any autodiff argument for\n  the solver will be ignored and a custom jacobian algorithm will be used.\n\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to false. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n  Reference for Lobatto and Radau methods:\n  ```bibtex\n      @Inbook{Jay2015,\n      author=\"Jay, Laurent O.\",\n      editor=\"Engquist, Bj{\"o}rn\",\n      title=\"Lobatto Methods\",\n      booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n      year=\"2015\",\n      publisher=\"Springer Berlin Heidelberg\",\n      }\n      @incollection{engquist_radau_2015,\n      author = {Hairer, Ernst and Wanner, Gerhard},\n      title = {Radau {Methods}},\n      booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n      publisher = {Springer Berlin Heidelberg},\n      editor=\"Engquist, Bj{\"o}rn\",\n      year = {2015},\n  }\n  ```\n  References for implementation of defect control, based on the `bvp5c` solver in MATLAB:\n  ```bibtex\n  @article{shampine_solving_nodate,\n  title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n  author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n  year = {2000},\n  }\n\n  @article{kierzenka_bvp_2008,\n      title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n      author = {Kierzenka, J and Shampine, L F},\n      year = {2008},\n  }\n\n  @article{russell_adaptive_1978,\n      title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n      journal = {SIAM Journal on Numerical Analysis},\n      author = {Russell, R. D. and Christiansen, J.},\n      year = {1978},\n      file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n  }\n  ```\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIb2","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIb2","text":"  LobattoIIIb2(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n2th stage LobattoIIIb method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIb3","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIb3","text":"  LobattoIIIb3(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n3th stage LobattoIIIb method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIb4","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIb4","text":"  LobattoIIIb4(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n4th stage LobattoIIIb method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIb5","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIb5","text":"  LobattoIIIb5(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n5th stage LobattoIIIb method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\n    title = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\n    author = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\n    year = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIc2","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIc2","text":"  LobattoIIIc2(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n2th stage LobattoIIIc method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\ntitle = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\nauthor = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\nyear = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIc3","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIc3","text":"  LobattoIIIc3(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n3th stage LobattoIIIc method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\ntitle = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\nauthor = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\nyear = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIc4","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIc4","text":"  LobattoIIIc4(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n4th stage LobattoIIIc method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\ntitle = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\nauthor = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\nyear = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/firk/#BoundaryValueDiffEqFIRK.LobattoIIIc5","page":"BoundaryValueDiffEqFIRK","title":"BoundaryValueDiffEqFIRK.LobattoIIIc5","text":"  LobattoIIIc5(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(), nested_nlsolve = false, nest_tol = 0.0,\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n5th stage LobattoIIIc method.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff)).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode defaults to AutoSparse(AutoForwardDiff) if possible else AutoSparse(AutoFiniteDiff). For bc_diffmode, defaults to AutoForwardDiff if possible else AutoFiniteDiff.\nnested_nlsolve: Whether or not to use a nested nonlinear solve for the implicit FIRK step. Defaults to true. If set to false, the FIRK stages are solved as a part of the global residual. The general recommendation is to choose true for larger problems and false for smaller ones.\nnest_tol: The tolerance for the nested solver. Default is nothing which leads to NonlinearSolve automatically selecting the tolerance.\ndefect_threshold: Threshold for defect control.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\nReference for Lobatto and Radau methods:\n\n@Inbook{Jay2015,\n    author=\"Jay, Laurent O.\",\n    editor=\"Engquist, Bj{\"o}rn\",\n    title=\"Lobatto Methods\",\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    year=\"2015\",\n    publisher=\"Springer Berlin Heidelberg\",\n}\n@incollection{engquist_radau_2015,\n    author = {Hairer, Ernst and Wanner, Gerhard},\n    title = {Radau {Methods}},\n    booktitle = {Encyclopedia of {Applied} and {Computational} {Mathematics}},\n    publisher = {Springer Berlin Heidelberg},\n    editor=\"Engquist, Bj{\"o}rn\",\n    year = {2015},\n}\n\nReferences for implementation of defect control, based on the bvp5c solver in MATLAB:\n\n@article{shampine_solving_nodate,\ntitle = {Solving {Boundary} {Value} {Problems} for {Ordinary} {Diﬀerential} {Equations} in {Matlab} with bvp4c\nauthor = {Shampine, Lawrence F and Kierzenka, Jacek and Reichelt, Mark W},\nyear = {2000},\n}\n\n@article{kierzenka_bvp_2008,\n    title = {A {BVP} {Solver} that {Controls} {Residual} and {Error}},\n    author = {Kierzenka, J and Shampine, L F},\n    year = {2008},\n}\n\n@article{russell_adaptive_1978,\n    title = {Adaptive {Mesh} {Selection} {Strategies} for {Solving} {Boundary} {Value} {Problems}},\n    journal = {SIAM Journal on Numerical Analysis},\n    author = {Russell, R. D. and Christiansen, J.},\n    year = {1978},\n    file = {Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:/Users/AXLRSN/Zotero/storage/HKU27A4T/Russell and Christiansen - 1978 - Adaptive Mesh Selection Strategies for Solving Bou.pdf:application/pdf},\n}\n\n\n\n\n\n","category":"type"},{"location":"tutorials/solve_nlls_bvp/#Solve-Overdetermined-and-Underdetermined-BVP","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"","category":"section"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"When there are more or less boundary conditions than the states in a boundary value problem, the BVP would become an overdetermined or underdetermined boundary value problem. As for these kinds of special BVPs, the solving workflow are similar with solving standard BVPs in BoundaryValueDiffEq.jl, but we need to specify the prototype of boundary conditions to tell BoundaryValueDiffEq.jl the structure of our boundary conditions with bcresid_prototype in BVPFunction.","category":"page"},{"location":"tutorials/solve_nlls_bvp/#Solve-Overdetermined-BVP","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined BVP","text":"","category":"section"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"For example, consider an overdetermined BVP given by the system of differential equations","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"y_1=y_2\ny_2=-y_1","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"with boundary conditions of","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"y_1(0)=0 y_1(100)=1 y_2(100) = -1729109","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"The test BVP has two state variables but three boundary conditions, which means there are additional constraints on the solution.","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"using BoundaryValueDiffEq, Plots\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -u[1]\nend\nfunction bc!(resid, sol, p, t)\n    solₜ₁ = sol(0.0)\n    solₜ₂ = sol(100.0)\n    resid[1] = solₜ₁[1]\n    resid[2] = solₜ₂[1] - 1\n    resid[3] = solₜ₂[2] + 1.729109\nend\ntspan = (0.0, 100.0)\nu0 = [0.0, 1.0]\nprob = BVProblem(BVPFunction(f!, bc!; bcresid_prototype = zeros(3)), u0, tspan)\nsol = solve(prob, MIRK4(), dt = 0.01, abstol = 1e-3)\nplot(sol)","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"Since this BVP imposes constaints only at the two endpoints, we can use TwoPointBVProlem to handle such cases.","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"function f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -u[1]\nend\nbca!(resid, ua, p) = (resid[1] = ua[1])\nbcb!(resid, ub, p) = (resid[1] = ub[1] - 1; resid[2] = ub[2] + 1.729109)\nprob = TwoPointBVProblem(\n    BVPFunction(\n        f!, (bca!, bcb!); twopoint = Val(true), bcresid_prototype = (zeros(1), zeros(2))),\n    u0,\n    tspan)","category":"page"},{"location":"tutorials/solve_nlls_bvp/#Solve-Underdetermined-BVP","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Underdetermined BVP","text":"","category":"section"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"Let's see an example of underdetermined BVP, consider an horizontal metal beam of length L subject to a vertical load q(x) per unit length, the resulting beam displacement satisfies the differential equation","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"EIy(x)=q(x)","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"with boundary condition y(0)=y(L)=0, E is the Young's modulus and I is the moment of inertia of the beam's cross section. Here we consider the simplified version and transform this BVP into a first order BVP system:","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"y_1=y_2\ny_2=y_3\ny_3=y_4\ny_4=0","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"using BoundaryValueDiffEq, Plots\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = u[3]\n    du[3] = u[4]\n    du[4] = 0\nend\nfunction bc!(resid, sol, p, t)\n    solₜ₁ = sol(0.0)\n    solₜ₂ = sol(1.0)\n    resid[1] = solₜ₁[1]\n    resid[2] = solₜ₂[1]\nend\nxspan = (0.0, 1.0)\nu0 = [0.0, 1.0, 0.0, 1.0]\nprob = BVProblem(BVPFunction(f!, bc!; bcresid_prototype = zeros(2)), u0, xspan)\nsol = solve(prob, MIRK4(), dt = 0.01)\nplot(sol)","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"Since this problem has less constraints than the state variables, so there would be infinitely many solutions with different u0 specified.","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"The above underdetermined is also being able to reformulated as TwoPointBVProblem","category":"page"},{"location":"tutorials/solve_nlls_bvp/","page":"Solve Overdetermined and Underdetermined BVP","title":"Solve Overdetermined and Underdetermined BVP","text":"function f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = u[3]\n    du[3] = u[4]\n    du[4] = 0\nend\nbca!(resid, ua, p) = (resid[1] = ua[1])\nbcb!(resid, ub, p) = (resid[1] = ub[1])\nxspan = (0.0, 1.0)\nu0 = [0.0, 1.0, 0.0, 1.0]\nprob = TwoPointBVProblem(\n    BVPFunction(\n        f!, (bca!, bcb!); twopoint = Val(true), bcresid_prototype = (zeros(1), zeros(1))),\n    u0,\n    xspan)","category":"page"},{"location":"devdocs/internal_interfaces/#Internal-Abstract-Types","page":"Internal Abstract Types","title":"Internal Abstract Types","text":"","category":"section"},{"location":"devdocs/internal_interfaces/#Solvers","page":"Internal Abstract Types","title":"Solvers","text":"","category":"section"},{"location":"devdocs/internal_interfaces/#BoundaryValueDiffEqCore.AbstractBoundaryValueDiffEqAlgorithm","page":"Internal Abstract Types","title":"BoundaryValueDiffEqCore.AbstractBoundaryValueDiffEqAlgorithm","text":"AbstractBoundaryValueDiffEqAlgorithm\n\nAbstract type for all boundary value problem algorithms.\n\n\n\n\n\n","category":"type"},{"location":"basics/autodiff/#Automatic-Differentiation-Backends","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"","category":"section"},{"location":"basics/autodiff/","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"note: Note\nWe support ForwardDiff.jl, FiniteDiff.jl, Enzyme.jl, Mooncake.jl and PolyesterForwardDiff.jl(PolyesterForwardDiff only for collocation methods) via DifferentiationInterface.jl. Please refer to the backends page for more information.","category":"page"},{"location":"basics/autodiff/","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"In BoundaryValueDiffEq.jl, automatic differentiation backend should only be wrapped in BVPJacobianAlgorithm(diffmode, bc_diffmode, nonbc_diffmode). BVPJacobianAlgorithm(diffmode, bc_diffmode, nonbc_diffmode) supports user-specified mixed automatic differentiation backends in differrent part of a boundary value problem, and AD choice should depended on the type of boundary value problem:","category":"page"},{"location":"basics/autodiff/","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"BVProblem: Differentiation mode for boundary condition part and non boundary condition part should be specified, for example, BVPJacobianAlgorithm(; bc_diffmode, nonbc_diffmode), default to BVPJacobianAlgorithm(; bc_diffmode = AutoForwardDiff(), nonbc_diffmode = AutoSparse(AutoForwardDiff())).\nTwoPointBVProblem: Differentiation mode for overall solving should be specified, for example, BVPJacobianAlgorithm(; diffmode), default to BVPJacobianAlgorithm(; diffmode = AutoSparse(AutoForwardDiff())).","category":"page"},{"location":"basics/autodiff/","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"In BoundaryValueDiffEq.jl, we require AD to obtain the Jacobian of the loss function which contains the collocation equation and boundary condition equations. For TwoPointBVProblem, the Jacobian of the loss function is a sparse banded matrix with known sparsity pattern, but for general multi-points BVProblem, the Jacobian of the loss function is an almost banded matrix, which has the first several rows as the boundary conditions and the rest as a sparse banded matrix with known sparsity pattern but without the first several rows. In this case, we can specify mixed AD backend in BVPJacobianAlgorithm to make the most of the different sparsity pattern to accelerate BVP solving process.","category":"page"},{"location":"basics/autodiff/#Summary-of-Finite-Differencing-Backends","page":"Automatic Differentiation Backends","title":"Summary of Finite Differencing Backends","text":"","category":"section"},{"location":"basics/autodiff/","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"AutoFiniteDiff: Finite differencing using FiniteDiff.jl, not optimal but always applicable.","category":"page"},{"location":"basics/autodiff/#Summary-of-Forward-Mode-AD-Backends","page":"Automatic Differentiation Backends","title":"Summary of Forward Mode AD Backends","text":"","category":"section"},{"location":"basics/autodiff/","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"AutoForwardDiff: The best choice for dense problems.\nAutoPolyesterForwardDiff: Might be faster than AutoForwardDiff for large problems. Requires PolyesterForwardDiff.jl to be installed and loaded.\nAutoEnzyme(; mode = Enzyme.Forward): Source transformation forward mode AD.","category":"page"},{"location":"basics/autodiff/#Summary-of-Reverse-Mode-AD-Backends","page":"Automatic Differentiation Backends","title":"Summary of Reverse Mode AD Backends","text":"","category":"section"},{"location":"basics/autodiff/","page":"Automatic Differentiation Backends","title":"Automatic Differentiation Backends","text":"AutoEnzyme(; mode = Enzyme.Reverse): Source transformation reverse mode AD.\nAutoMooncake(; config = nothing): Source transformation reverse mode AD.","category":"page"},{"location":"solvers/ascher/#ascher","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher","text":"","category":"section"},{"location":"solvers/ascher/","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher","text":"Gauss Legendre collocation methods with Ascher's error control adaptivity and mesh refinement routines. To be able to access the solvers in BoundaryValueDiffEqFIRK, you must first install them use the Julia package manager:","category":"page"},{"location":"solvers/ascher/","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher","text":"using Pkg\nPkg.add(\"BoundaryValueDiffEqAscher\")","category":"page"},{"location":"solvers/ascher/","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher","text":"solve(prob::BVProblem, alg, dt; kwargs...)\nsolve(prob::TwoPointBVProblem, alg, dt; kwargs...)","category":"page"},{"location":"solvers/ascher/#Full-List-of-Methods","page":"BoundaryValueDiffEqAscher","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/ascher/","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher","text":"Ascher1: 1 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher2: 2 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher3: 3 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher4: 4 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher5: 5 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher6: 6 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.\nAscher7: 7 stage Gauss Legendre collocation method with Ascher's error control adaptivity and mesh refinement.","category":"page"},{"location":"solvers/ascher/#Detailed-Solvers-Explanation","page":"BoundaryValueDiffEqAscher","title":"Detailed Solvers Explanation","text":"","category":"section"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher1","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher1","text":"Ascher1(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n1th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher2","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher2","text":"Ascher2(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n2th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher3","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher3","text":"Ascher3(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n3th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher4","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher4","text":"Ascher4(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n4th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher5","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher5","text":"Ascher5(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n5th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher6","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher6","text":"Ascher6(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n6th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/ascher/#BoundaryValueDiffEqAscher.Ascher7","page":"BoundaryValueDiffEqAscher","title":"BoundaryValueDiffEqAscher.Ascher7","text":"Ascher7(; nlsolve = NewtonRaphson(), max_num_subintervals = 3000)\n\n7th stage Gauss Legendre collocation methods with adaptivity adapted from Ascher's implementation.\n\nKeyword Arguments\n\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\nmax_num_subintervals: Number of maximal subintervals, default as 3000.\nzeta: side condition points, should always be provided.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Ascher1994CollocationSF,\n    title={Collocation Software for Boundary Value Differential-Algebraic Equations},\n    author={Uri M. Ascher and Raymond J. Spiteri},\n    journal={SIAM J. Sci. Comput.},\n    year={1994},\n    volume={15},\n    pages={938-952},\n    url={https://api.semanticscholar.org/CorpusID:10597070}\n}\n\n@article{Ascher1979ACS,\n    title={A collocation solver for mixed order systems of boundary value problems},\n    author={Uri M. Ascher and J. Christiansen and Robert D. Russell},\n    journal={Mathematics of Computation},\n    year={1979},\n    volume={33},\n    pages={659-679},\n    url={https://api.semanticscholar.org/CorpusID:121729124}\n}\n\n\n\n\n\n","category":"type"},{"location":"basics/solve/#solver_options","page":"Common Solver Options (Solve Keyword Arguments)","title":"Common Solver Options (Solve Keyword Arguments)","text":"","category":"section"},{"location":"basics/solve/","page":"Common Solver Options (Solve Keyword Arguments)","title":"Common Solver Options (Solve Keyword Arguments)","text":"abstol::Number: The absolute tolerance. Defaults to 1e-6.\nadaptive::Bool: Whether the error control adaptivity is on, default as true.\ncontroller: Error controller for collocation methods, default as DefectControl(), more controller options in Error Control Adaptivity.\ndefect_threshold: Monitor of the size of defect norm. Defaults to 0.1.\nodesolve_kwargs: OrdinaryDiffEq.jl solvers kwargs for passing to ODE solving in shooting methods. For more information, see the documentation for OrdinaryDiffEq: Common Solver Options.\nnlsolve_kwargs: NonlinearSolve.jl solvers kwargs for passing to nonlinear solving in collocation methods and shooting methods. For more information, see the documentation for NonlinearSolve: Commom Solver Options. The default absolute tolerance of nonlinear solving in collocaio\nverbose:  Toggles whether warnings are thrown when the solver exits early. Defaults to true.\nensemblealg: Whether MultipleShooting uses multithreading, default as EnsembleThreads(). For more information, see the documentation for OrdinaryDiffEq: EnsembleAlgorithms.","category":"page"},{"location":"solvers/mirkn/#mirkn","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN","text":"","category":"section"},{"location":"solvers/mirkn/","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN","text":"Monotonic Implicit Runge Kutta Nyström(MIRKN) Methods. To only use the MIRKN methods form BoundaryVaueDiffEq.jl, you need to install them use the Julia package manager:","category":"page"},{"location":"solvers/mirkn/","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN","text":"using Pkg\nPkg.add(\"BoundaryValueDiffEqMIRKN\")","category":"page"},{"location":"solvers/mirkn/","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN","text":"solve(prob::SecondOrderBVProblem, alg, dt; kwargs...)\nsolve(prob::TwoPointSecondOrderBVProblem, alg, dt; kwargs...)","category":"page"},{"location":"solvers/mirkn/","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN","text":"note: Defect control adaptivity\nMIRKN don't have defect control adaptivity","category":"page"},{"location":"solvers/mirkn/#Full-List-of-Methods","page":"BoundaryValueDiffEqMIRKN","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/mirkn/","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN","text":"MIRKN4: 4 stage Monotonic Implicit Runge-Kutta-Nyström method, with no error control adaptivity.\nMIRKN6: 4 stage Monotonic Implicit Runge-Kutta-Nyström method, with no error control adaptivity.","category":"page"},{"location":"solvers/mirkn/#Detailed-Solvers-Explanation","page":"BoundaryValueDiffEqMIRKN","title":"Detailed Solvers Explanation","text":"","category":"section"},{"location":"solvers/mirkn/#BoundaryValueDiffEqMIRKN.MIRKN4","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN.MIRKN4","text":"  MIRKN4(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n4th order Monotonic Implicit Runge Kutta Nyström method.\n\nKeyword Arguments\n\n- `nlsolve`: Internal Nonlinear solver. Any solver which conforms to the SciML\n  `NonlinearProblem` interface can be used. Note that any autodiff argument for\n  the solver will be ignored and a custom jacobian algorithm will be used.\n- `jac_alg`: Jacobian Algorithm used for the nonlinear solver. Defaults to\n  `BVPJacobianAlgorithm()`, which automatically decides the best algorithm to\n  use based on the input types and problem type.\n  - For `TwoPointBVProblem`, only `diffmode` is used (defaults to\n    `AutoSparse(AutoForwardDiff())` if possible else `AutoSparse(AutoFiniteDiff())`).\n  - For `BVProblem`, `bc_diffmode` and `nonbc_diffmode` are used. For\n    `nonbc_diffmode` defaults to `AutoSparse(AutoForwardDiff())` if possible else\n    `AutoSparse(AutoFiniteDiff())`. For `bc_diffmode`, defaults to `AutoForwardDiff` if\n    possible else `AutoFiniteDiff`.\n- `defect_threshold`: Threshold for defect control.\n- `max_num_subintervals`: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Muir2001MonoImplicitRM,\n    title={Mono-Implicit Runge-Kutta-Nystr{\"o}m Methods with Application to Boundary Value Ordinary Differential Equations},\n    author={Paul H. Muir and Mark F. Adams},\n    journal={BIT Numerical Mathematics},\n    year={2001},\n    volume={41},\n    pages={776-799}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/mirkn/#BoundaryValueDiffEqMIRKN.MIRKN6","page":"BoundaryValueDiffEqMIRKN","title":"BoundaryValueDiffEqMIRKN.MIRKN6","text":"  MIRKN6(; nlsolve = NewtonRaphson(), jac_alg = BVPJacobianAlgorithm(),\n          defect_threshold = 0.1, max_num_subintervals = 3000)\n\n6th order Monotonic Implicit Runge Kutta Nyström method.\n\nKeyword Arguments\n\n- `nlsolve`: Internal Nonlinear solver. Any solver which conforms to the SciML\n  `NonlinearProblem` interface can be used. Note that any autodiff argument for\n  the solver will be ignored and a custom jacobian algorithm will be used.\n- `jac_alg`: Jacobian Algorithm used for the nonlinear solver. Defaults to\n  `BVPJacobianAlgorithm()`, which automatically decides the best algorithm to\n  use based on the input types and problem type.\n  - For `TwoPointBVProblem`, only `diffmode` is used (defaults to\n    `AutoSparse(AutoForwardDiff())` if possible else `AutoSparse(AutoFiniteDiff())`).\n  - For `BVProblem`, `bc_diffmode` and `nonbc_diffmode` are used. For\n    `nonbc_diffmode` defaults to `AutoSparse(AutoForwardDiff())` if possible else\n    `AutoSparse(AutoFiniteDiff())`. For `bc_diffmode`, defaults to `AutoForwardDiff` if\n    possible else `AutoFiniteDiff`.\n- `defect_threshold`: Threshold for defect control.\n- `max_num_subintervals`: Number of maximal subintervals, default as 3000.\n\nnote: Note\nFor type-stability, the chunksizes for ForwardDiff ADTypes in BVPJacobianAlgorithm must be provided.\n\nReferences\n\n@article{Muir2001MonoImplicitRM,\n    title={Mono-Implicit Runge-Kutta-Nystr{\"o}m Methods with Application to Boundary Value Ordinary Differential Equations},\n    author={Paul H. Muir and Mark F. Adams},\n    journal={BIT Numerical Mathematics},\n    year={2001},\n    volume={41},\n    pages={776-799}\n}\n\n\n\n\n\n","category":"type"},{"location":"solvers/shooting/#shooting","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting","text":"","category":"section"},{"location":"solvers/shooting/","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting","text":"Single shooting method and multiple shooting method. To only use the Shooting methods form BoundaryVaueDiffEq.jl, you need to install them use the Julia package manager:","category":"page"},{"location":"solvers/shooting/","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting","text":"using Pkg\nPkg.add(\"BoundaryValueDiffEqShooting\")","category":"page"},{"location":"solvers/shooting/","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting","text":"note: Require OrdinaryDiffEq\nShooting methods require OrdinaryDiffEq.jl loaded to use the ODE solvers","category":"page"},{"location":"solvers/shooting/","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting","text":"solve(prob::BVProblem, alg; kwargs...)\nsolve(prob::TwoPointBVProblem, alg; kwargs...)","category":"page"},{"location":"solvers/shooting/","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting","text":"Shooting methods should be use together with ODE solvers:","category":"page"},{"location":"solvers/shooting/","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting","text":"BoundaryValueDiffEqShooting.Shooting\nBoundaryValueDiffEqShooting.MultipleShooting","category":"page"},{"location":"solvers/shooting/#Full-List-of-Methods","page":"BoundaryValueDiffEqShooting","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/shooting/","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting","text":"Shooting: Single shooting methods, reduces BVP to an initial value problem and solves the IVP.\nMultipleShooting: Reduces BVP to an initial value problem and solves the IVP. Significantly more stable than Single Shooting.","category":"page"},{"location":"solvers/shooting/#Detailed-Solvers-Explanation","page":"BoundaryValueDiffEqShooting","title":"Detailed Solvers Explanation","text":"","category":"section"},{"location":"solvers/shooting/#BoundaryValueDiffEqShooting.Shooting","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting.Shooting","text":"Shooting(ode_alg; kwargs...)\nShooting(ode_alg, nlsolve; kwargs...)\nShooting(; ode_alg = nothing, nlsolve = nothing, jac_alg = nothing)\n\nSingle shooting method, reduces BVP to an initial value problem and solves the IVP.\n\nArguments\n\node_alg: ODE algorithm to use for solving the IVP. Any solver which conforms to the SciML ODEProblem interface can be used! (Defaults to nothing which will use poly-algorithm if DifferentialEquations.jl is loaded else this must be supplied)\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used. Note that any autodiff argument for the solver will be ignored and a custom jacobian algorithm will be used.\njac_alg: Jacobian Algorithm used for the Nonlinear Solver. If this is not set, we check if nlsolve.ad exists and is not nothing. If it is, we use that to construct the jacobian. If not, we try to use the best algorithm based on the input types and problem type. If BVPJacobianAlgorithm is provided, only diffmode is used (defaults to AutoForwardDiff if possible else AutoFiniteDiff).\n\n\n\n\n\n","category":"type"},{"location":"solvers/shooting/#BoundaryValueDiffEqShooting.MultipleShooting","page":"BoundaryValueDiffEqShooting","title":"BoundaryValueDiffEqShooting.MultipleShooting","text":"MultipleShooting(; nshoots::Int, ode_alg = nothing, nlsolve = nothing,\n    grid_coarsening = true, jac_alg = nothing)\nMultipleShooting(nshoots::Int; kwargs...)\nMultipleShooting(nshoots::Int, ode_alg; kwargs...)\nMultipleShooting(nshoots::Int, ode_alg, nlsolve; kwargs...)\n\nMultiple Shooting method, reduces BVP to an initial value problem and solves the IVP. Significantly more stable than Single Shooting.\n\nArguments\n\nnshoots: Number of shooting points.\node_alg: ODE algorithm to use for solving the IVP. Any solver which conforms to the SciML ODEProblem interface can be used! (Defaults to nothing which will use poly-algorithm if DifferentialEquations.jl is loaded else this must be supplied)\nnlsolve: Internal Nonlinear solver. Any solver which conforms to the SciML NonlinearProblem interface can be used.\njac_alg: Jacobian Algorithm used for the nonlinear solver. Defaults to BVPJacobianAlgorithm(), which automatically decides the best algorithm to use based on the input types and problem type.\nFor TwoPointBVProblem, only diffmode is used (defaults to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff())).\nFor BVProblem, bc_diffmode and nonbc_diffmode are used. For nonbc_diffmode we default to AutoSparse(AutoForwardDiff()) if possible else AutoSparse(AutoFiniteDiff()). For bc_diffmode, we default to AutoForwardDiff if possible else AutoFiniteDiff.\ngrid_coarsening: Coarsening the multiple-shooting grid to generate a stable IVP solution. Possible Choices:\ntrue: Halve the grid size, till we reach a grid size of 1.\nfalse: Do not coarsen the grid. Solve a Multiple Shooting Problem and finally solve a Single Shooting Problem.\nAbstractVector{<:Int} or Ntuple{N, <:Integer}: Use the provided grid coarsening. For example, if nshoots = 10 and grid_coarsening = [5, 2], then the grid will be coarsened to [5, 2]. Note that 1 should not be present in the grid coarsening.\nFunction: Takes the current number of shooting points and returns the next number of shooting points. For example, if nshoots = 10 and grid_coarsening = n -> n ÷ 2, then the grid will be coarsened to [5, 2].\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_functions/#bvpfunctions","page":"BVP Functions and Jacobian Types","title":"BVP Functions and Jacobian Types","text":"","category":"section"},{"location":"basics/bvp_functions/","page":"BVP Functions and Jacobian Types","title":"BVP Functions and Jacobian Types","text":"The SciML ecosystem provides an extensive interface for declaring extra functions associated with the boundary value probems's data. In traditional libraries, there is usually only few options: the Jacobian and the Jacobian of boundary conditions. However, we allow for a large array of pre-computed functions to speed up the calculations. This is offered via the BVPFunction types, which can be passed to the problems.","category":"page"},{"location":"basics/bvp_functions/#Function-Type-Definitions","page":"BVP Functions and Jacobian Types","title":"Function Type Definitions","text":"","category":"section"},{"location":"basics/bvp_functions/#SciMLBase.BVPFunction","page":"BVP Functions and Jacobian Types","title":"SciMLBase.BVPFunction","text":"DocStringExtensions.TypeDefinition()\n\nA representation of a BVP function f, defined by:\n\nfracdudt = f(u p t)\n\nand the constraints:\n\ng(u p t) = 0\n\nIf the size of g(u, p, t) is different from the size of u, then the constraints are interpreted as a least squares problem, i.e. the objective function is:\n\nmin_u  g_i(u p t) ^2\n\nand all of its related functions, such as the Jacobian of f, its gradient with respect to time, and more. For all cases, u0 is the initial condition, p are the parameters, and t is the independent variable.\n\nBVPFunction{iip, specialize}(f, bc;\n    mass_matrix = __has_mass_matrix(f) ? f.mass_matrix : I,\n    analytic = __has_analytic(f) ? f.analytic : nothing,\n    tgrad= __has_tgrad(f) ? f.tgrad : nothing,\n    jac = __has_jac(f) ? f.jac : nothing,\n    bcjac = __has_jac(bc) ? bc.jac : nothing,\n    jvp = __has_jvp(f) ? f.jvp : nothing,\n    vjp = __has_vjp(f) ? f.vjp : nothing,\n    jac_prototype = __has_jac_prototype(f) ? f.jac_prototype : nothing,\n    bcjac_prototype = __has_jac_prototype(bc) ? bc.jac_prototype : nothing,\n    sparsity = __has_sparsity(f) ? f.sparsity : jac_prototype,\n    paramjac = __has_paramjac(f) ? f.paramjac : nothing,\n    syms = nothing,\n    indepsym= nothing,\n    paramsyms = nothing,\n    colorvec = __has_colorvec(f) ? f.colorvec : nothing,\n    bccolorvec = __has_colorvec(f) ? bc.colorvec : nothing,\n    sys = __has_sys(f) ? f.sys : nothing,\n    twopoint::Union{Val, Bool} = Val(false))\n\nNote that both the function f and boundary condition bc are required. f should be given as f(du,u,p,t) or out = f(u,p,t). bc should be given as bc(res, u, p, t). See the section on iip for more details on in-place vs out-of-place handling.\n\nAll of the remaining functions are optional for improving or accelerating the usage of f and bc. These include:\n\nmass_matrix: the mass matrix M represented in the BVP function. Can be used to determine that the equation is actually a BVP for differential algebraic equation (DAE) if M is singular.\nanalytic(u0,p,t): used to pass an analytical solution function for the analytical solution of the BVP. Generally only used for testing and development of the solvers.\ntgrad(dT,u,h,p,t) or dT=tgrad(u,p,t): returns fracpartial f(upt)partial t\njac(J,du,u,p,gamma,t) or J=jac(du,u,p,gamma,t): returns fracdfdu\nbcjac(J,du,u,p,gamma,t) or J=jac(du,u,p,gamma,t): returns fracdbcdu\njvp(Jv,v,du,u,p,gamma,t) or Jv=jvp(v,du,u,p,gamma,t): returns the directional derivative fracdfdu v\nvjp(Jv,v,du,u,p,gamma,t) or Jv=vjp(v,du,u,p,gamma,t): returns the adjoint derivative fracdfdu^ast v\njac_prototype: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized Tridiagonal matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a SparseMatrixCSC with a correct sparsity pattern for the Jacobian. The default is nothing, which means a dense Jacobian.\nbcjac_prototype: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized Tridiagonal matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a SparseMatrixCSC with a correct sparsity pattern for the Jacobian. The default is nothing, which means a dense Jacobian.\nparamjac(pJ,u,p,t): returns the parameter Jacobian fracdfdp.\ncolorvec: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the jac_prototype. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to nothing, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.\nbccolorvec: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the bcjac_prototype. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to nothing, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.\n\nAdditional Options:\n\ntwopoint: Specify that the BVP is a two-point boundary value problem. Use Val(true) or Val(false) for type stability.\n\niip: In-Place vs Out-Of-Place\n\nFor more details on this argument, see the ODEFunction documentation.\n\nspecialize: Controlling Compilation and Specialization\n\nFor more details on this argument, see the ODEFunction documentation.\n\nFields\n\nThe fields of the BVPFunction type directly match the names of the inputs.\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_functions/#SciMLBase.DynamicalBVPFunction","page":"BVP Functions and Jacobian Types","title":"SciMLBase.DynamicalBVPFunction","text":"DocStringExtensions.TypeDefinition()\n\nA representation of a dynamical BVP function f, defined by:\n\nM fracddudt = f(duupt)\n\nalong with its boundary condition:\n\n\n\nand all of its related functions, such as the Jacobian of f, its gradient with respect to time, and more. For all cases, u0 is the initial condition, p are the parameters, and t is the independent variable.\n\nConstructor\n\nDynamicalBVPFunction{iip,specialize}(f, bc;\n                                    mass_matrix = __has_mass_matrix(f) ? f.mass_matrix : I,\n                                    analytic = __has_analytic(f) ? f.analytic : nothing,\n                                    tgrad= __has_tgrad(f) ? f.tgrad : nothing,\n                                    jac = __has_jac(f) ? f.jac : nothing,\n                                    jvp = __has_jvp(f) ? f.jvp : nothing,\n                                    vjp = __has_vjp(f) ? f.vjp : nothing,\n                                    jac_prototype = __has_jac_prototype(f) ? f.jac_prototype : nothing,\n                                    sparsity = __has_sparsity(f) ? f.sparsity : jac_prototype,\n                                    paramjac = __has_paramjac(f) ? f.paramjac : nothing,\n                                    colorvec = __has_colorvec(f) ? f.colorvec : nothing,\n                                    sys = __has_sys(f) ? f.sys : nothing\n                                    twopoint::Union{Val, Bool} = Val(false))\n\nNote that only the functions f_i themselves are required. These functions should be given as f_i!(du,du,u,p,t) or ddu = f_i(du,u,p,t). See the section on iip for more details on in-place vs out-of-place handling.\n\nAll of the remaining functions are optional for improving or accelerating the usage of f. These include:\n\nmass_matrix: the mass matrix M_i represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if M is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://docs.sciml.ai/DiffEqDocs/stable/solvers/daesolve/. Must be an AbstractArray or an AbstractSciMLOperator. Should be given as a tuple of mass matrices, i.e. `(M1, M_2)` for the mass matrices of equations 1 and 2 respectively.\nanalytic(u0,p,t): used to pass an analytical solution function for the analytical solution of the ODE. Generally only used for testing and development of the solvers.\ntgrad(dT,du,u,p,t) or dT=tgrad(du,u,p,t): returns fracpartial f(duupt)partial t\njac(J,du,u,p,t) or J=jac(du,u,p,t): returns fracdfdu\njvp(Jv,v,u,p,t) or Jv=jvp(v,u,p,t): returns the directional derivative fracdfdu v\nvjp(Jv,v,u,p,t) or Jv=vjp(v,u,p,t): returns the adjoint derivative fracdfdu^ast v\njac_prototype: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized Tridiagonal matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a SparseMatrixCSC with a correct sparsity pattern for the Jacobian. The default is nothing, which means a dense Jacobian.\nparamjac(pJ,du,u,p,t): returns the parameter Jacobian fracdfdp.\ncolorvec: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the jac_prototype. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to nothing, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.\n\niip: In-Place vs Out-Of-Place\n\nFor more details on this argument, see the ODEFunction documentation.\n\nspecialize: Controlling Compilation and Specialization\n\nFor more details on this argument, see the ODEFunction documentation.\n\nFields\n\nThe fields of the DynamicalBVPFunction type directly match the names of the inputs.\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_problem/#problems","page":"Boundary Value Problems","title":"Boundary Value Problems","text":"","category":"section"},{"location":"basics/bvp_problem/#The-Five-Types-of-Boundary-Value-Problems","page":"Boundary Value Problems","title":"The Five Types of Boundary Value Problems","text":"","category":"section"},{"location":"basics/bvp_problem/","page":"Boundary Value Problems","title":"Boundary Value Problems","text":"BoundaryValueDiffEq.jl tackles five related types of boundary value problems:","category":"page"},{"location":"basics/bvp_problem/","page":"Boundary Value Problems","title":"Boundary Value Problems","text":"General boundary value problems:, i.e., constraints are applied over the time span. Both overconstraints and underconstraints BVP are supported.\nTwo-point boundary value problems:, i.e., constraints are only applied at start and end of time span. Both overconstraints and underconstraints BVP are supported.\nGeneral second order boundary value problems, i.e., constraints for both solution and derivative of solution are applied over time span. Both overconstraints and underconstraints second order BVP are supported.\nSecond order two-point boundary value problems, i.e., constraints for both solution and derivative of solution are only applied at the start and end of the time span. Both overconstraints and underconstraints second order BVP are supported.\nBoundary value differential algebraic equations, i.e., apart from constraints applied over the time span, BVDAE has additional algebraic equations which state the algebraic relationship of different states in BVDAE.","category":"page"},{"location":"basics/bvp_problem/#Problem-Construction-Details","page":"Boundary Value Problems","title":"Problem Construction Details","text":"","category":"section"},{"location":"basics/bvp_problem/#SciMLBase.BVProblem","page":"Boundary Value Problems","title":"SciMLBase.BVProblem","text":"Defines an BVP problem. Documentation Page: https://docs.sciml.ai/DiffEqDocs/stable/types/bvp_types/\n\nMathematical Specification of a BVP Problem\n\nTo define a BVP Problem, you simply need to give the function f and the initial condition u_0 which define an ODE:\n\nfracdudt = f(upt)\n\nalong with an implicit function bc which defines the residual equation, where\n\nbc(upt) = 0\n\nis the manifold on which the solution must live. A common form for this is the two-point BVProblem where the manifold defines the solution at two points:\n\nu(t_0) = a\nu(t_f) = b\n\nProblem Type\n\nConstructors\n\nTwoPointBVProblem{isinplace}(f, bc, u0, tspan, p=NullParameters(); kwargs...)\nBVProblem{isinplace}(f, bc, u0, tspan, p=NullParameters(); kwargs...)\n\nor if we have an initial guess function initialGuess(p, t) for the given BVP, we can pass the initial guess to the problem constructors:\n\nTwoPointBVProblem{isinplace}(f, bc, initialGuess, tspan, p=NullParameters(); kwargs...)\nBVProblem{isinplace}(f, bc, initialGuess, tspan, p=NullParameters(); kwargs...)\n\nFor any BVP problem type, bc must be inplace if f is inplace. Otherwise it must be out-of-place.\n\nIf the bvp is a StandardBVProblem (also known as a Multi-Point BV Problem) it must define either of the following functions\n\nbc!(residual, u, p, t)\nresidual = bc(u, p, t)\n\nwhere residual computed from the current u. u is an array of solution values where u[i] is at time t[i], while p are the parameters. For a TwoPointBVProblem, t = tspan. For the more general BVProblem, u can be all of the internal time points, and for shooting type methods u=sol the ODE solution. Note that all features of the ODESolution are present in this form. In both cases, the size of the residual matches the size of the initial condition.\n\nIf the bvp is a TwoPointBVProblem then bc must be a Tuple (bca, bcb) and each of them must define either of the following functions:\n\nbegin\n    bca!(resid_a, u_a, p)\n    bcb!(resid_b, u_b, p)\nend\nbegin\n    resid_a = bca(u_a, p)\n    resid_b = bcb(u_b, p)\nend\n\nwhere resid_a and resid_b are the residuals at the two endpoints, u_a and u_b are the solution values at the two endpoints, and p are the parameters.\n\nParameters are optional, and if not given, then a NullParameters() singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nFields\n\nf: The function for the ODE.\nbc: The boundary condition function.\nu0: The initial condition. Either the initial condition for the ODE as an initial value problem, or a Vector of values for u(t_i) for collocation methods.\ntspan: The timespan for the problem.\np: The parameters for the problem. Defaults to NullParameters\nkwargs: The keyword arguments passed onto the solves.\n\nSpecial Keyword Arguments\n\nnlls: Specify that the BVP is a nonlinear least squares problem. Use Val(true) or Val(false) for type stability. By default this is automatically inferred based on the size of the input and outputs, however this is type unstable for any array type that doesn't store array size as part of type information. If we can't reliably infer this, we set it to Nothing. Downstreams solvers must be setup to deal with this case.\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_problem/#SciMLBase.TwoPointBVProblem","page":"Boundary Value Problems","title":"SciMLBase.TwoPointBVProblem","text":"struct TwoPointBVProblem{iip}\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_problem/#SciMLBase.SecondOrderBVProblem","page":"Boundary Value Problems","title":"SciMLBase.SecondOrderBVProblem","text":"Defines a second order BVP problem. Documentation Page: https://docs.sciml.ai/DiffEqDocs/stable/types/bvp_types/\n\nMathematical Specification of a second order BVP Problem\n\nTo define a second order BVP Problem, you simply need to give the function f and the initial condition u_0 which define an ODE:\n\nfracddudt = f(duupt)\n\nalong with an implicit function bc which defines the residual equation, where\n\nbc(duupt) = 0\n\nis the manifold on which the solution must live. A common form for this is the two-point SecondOrderBVProblem where the manifold defines the solution at two points:\n\ng(u(t_0)u(t_0)) = 0\ng(u(t_f)u(t_f)) = 0\n\nProblem Type\n\nConstructors\n\nTwoPointSecondOrderBVProblem{isinplace}(f, bc, u0, tspan, p=NullParameters(); kwargs...)\nSecondOrderBVProblem{isinplace}(f, bc, u0, tspan, p=NullParameters(); kwargs...)\n\nor if we have an initial guess function initialGuess(p, t) for the given BVP, we can pass the initial guess to the problem constructors:\n\nTwoPointSecondOrderBVProblem{isinplace}(f, bc, initialGuess, tspan, p=NullParameters(); kwargs...)\nSecondOrderBVProblem{isinplace}(f, bc, initialGuess, tspan, p=NullParameters(); kwargs...)\n\nFor any BVP problem type, bc must be inplace if f is inplace. Otherwise it must be out-of-place.\n\nIf the bvp is a StandardSecondOrderBVProblem (also known as a Multi-Point BV Problem) it must define either of the following functions\n\nbc!(residual, du, u, p, t)\nresidual = bc(du, u, p, t)\n\nwhere residual computed from the current u. u is an array of solution values where u[i] is at time t[i], while p are the parameters. For a TwoPointBVProblem, t = tspan. For the more general BVProblem, u can be all of the internal time points, and for shooting type methods u=sol the ODE solution. Note that all features of the ODESolution are present in this form. In both cases, the size of the residual matches the size of the initial condition.\n\nIf the bvp is a TwoPointSecondOrderBVProblem then bc must be a Tuple (bca, bcb) and each of them must define either of the following functions:\n\nbegin\n    bca!(resid_a, du_a, u_a, p)\n    bcb!(resid_b, du_b, u_b, p)\nend\nbegin\n    resid_a = bca(du_a, u_a, p)\n    resid_b = bcb(du_b, u_b, p)\nend\n\nwhere resid_a and resid_b are the residuals at the two endpoints, u_a and u_b are the solution values at the two endpoints, du_a and du_b are the derivative of solution values at the two endpoints, and p are the parameters.\n\nParameters are optional, and if not given, then a NullParameters() singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a callback in the problem, then that callback will be added in every solve call.\n\nFields\n\nf: The function for the ODE.\nbc: The boundary condition function.\nu0: The initial condition. Either the initial condition for the ODE as an initial value problem, or a Vector of values for u(t_i) for collocation methods.\ntspan: The timespan for the problem.\np: The parameters for the problem. Defaults to NullParameters\nkwargs: The keyword arguments passed onto the solves.\n\n\n\n\n\n","category":"type"},{"location":"basics/bvp_problem/#SciMLBase.TwoPointSecondOrderBVProblem","page":"Boundary Value Problems","title":"SciMLBase.TwoPointSecondOrderBVProblem","text":"struct TwoPointSecondOrderBVProblem{iip}\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#error_control","page":"Error Control Adaptivity","title":"Error Control Adaptivity","text":"","category":"section"},{"location":"basics/error_control/","page":"Error Control Adaptivity","title":"Error Control Adaptivity","text":"Adaptivity helps ensure the quality of the our numerical solution, and when our solution exhibits significant estimating errors, adaptivity automatically refine the mesh based on the error distribution, and providing a final satisfying solution.","category":"page"},{"location":"basics/error_control/","page":"Error Control Adaptivity","title":"Error Control Adaptivity","text":"When comes to solving ill-conditioned BVP, for example the singular pertubation problem where the small parameters become extremally small leading to the layers phonemona, the error control adaptivity becomes even more critical, because the minor pertubations can lead to large deviation in the solution. In such cases, adaptivity autimatically figure out where to use refined mesh and where to use coarse mesh to achieve the balance of computational efficiency and accuracy.","category":"page"},{"location":"basics/error_control/","page":"Error Control Adaptivity","title":"Error Control Adaptivity","text":"BoundaryValuDiffEq.jl support error control adaptivity for collocation methods, and the adaptivity is default as defect control adaptivity when using adaptive collocation solvers:","category":"page"},{"location":"basics/error_control/","page":"Error Control Adaptivity","title":"Error Control Adaptivity","text":"sol = solve(prob, MIRK4(), dt = 0.01, adaptive = true)","category":"page"},{"location":"basics/error_control/","page":"Error Control Adaptivity","title":"Error Control Adaptivity","text":"Actually, BoundaryValueDiffEq.jl supports both defect and global error control adaptivity(while the defect control is the default controller) Boisvert et al. [4], to specify different error control metods, we simply need to specify the controller keyword in solve:","category":"page"},{"location":"basics/error_control/","page":"Error Control Adaptivity","title":"Error Control Adaptivity","text":"sol = solve(prob, MIRK4(), dt = 0.01, controller = GlobalErrorControl()) # Use global error control\nsol = solve(prob, MIRK4(), dt = 0.01, controller = SequentialErrorControl()) # Use Sequential error control\nsol = solve(prob, MIRK4(), dt = 0.01, controller = HybridErrorControl()) # Use Hybrid error control","category":"page"},{"location":"basics/error_control/#Error-control-methods","page":"Error Control Adaptivity","title":"Error control methods","text":"","category":"section"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.DefectControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.DefectControl","text":"DefectControl(; defect_threshold = 0.1)\n\nDefect estimation method with defect defined as\n\ndefect = maxfracS(x) - f(xS(x))1 + f(xS(x))\n\nDefect controller, with the maximum defect_threshold as 0.1, when the estimating defect is greater than the defect_threshold, the mesh will be refined.\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.GlobalErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.GlobalErrorControl","text":"GlobalErrorControl(; method = HOErorControl())\n\nGlobal error controller, use high order global error estimation method HOErrorControl as default.\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.SequentialErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.SequentialErrorControl","text":"SequentialErrorControl(; defect = DefectControl(), global_error = GlobalErrorControl())\n\nFirst use the defect controller, if the defect is satisfying, then use global error controller.\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.HybridErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.HybridErrorControl","text":"HybridErrorControl(; DE = 1.0, GE = 1.0, defect = DefectControl(), global_error = GlobalErrorControl())\n\nControl both of the defect and global error, where the error norm is the linear combination of the defect and global error.\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.NoErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.NoErrorControl","text":"NoErrorControl()\n\nNo error control method.\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/","page":"Error Control Adaptivity","title":"Error Control Adaptivity","text":"While we can achieve global error control in different ways, we can use different methods to estimate the global error:","category":"page"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.HOErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.HOErrorControl","text":"HOErrorControl()\n\nHigher order global error estimation method\n\nUses a solution from order+2 method on the original mesh and calculate the error with\n\nerror = maxfracu_p - u_p+21 + u_p\n\n\n\n\n\n","category":"type"},{"location":"basics/error_control/#BoundaryValueDiffEqCore.REErrorControl","page":"Error Control Adaptivity","title":"BoundaryValueDiffEqCore.REErrorControl","text":"REErrorControl()\n\nRichardson extrapolation global error estimation method\n\nUse Richardson extrapolation to calculate the error on the doubled mesh with\n\nerror = frac2^p2^p-1 * maxfracu_h - u_h21 + u_h\n\n\n\n\n\n","category":"type"},{"location":"solvers/simple_solvers/#simpleboundaryvaluediffeq","page":"SimpleBoundaryValueDiffEq","title":"SimpleBoundaryValueDiffEq","text":"","category":"section"},{"location":"solvers/simple_solvers/#Full-List-of-Methods","page":"SimpleBoundaryValueDiffEq","title":"Full List of Methods","text":"","category":"section"},{"location":"solvers/simple_solvers/","page":"SimpleBoundaryValueDiffEq","title":"SimpleBoundaryValueDiffEq","text":"SimpleBoundaryValueDiffEq.SimpleMIRK4\nSimpleBoundaryValueDiffEq.SimpleMIRK5\nSimpleBoundaryValueDiffEq.SimpleMIRK6\nSimpleBoundaryValueDiffEq.SimpleShooting","category":"page"},{"location":"tutorials/getting_started/#Get-Started-with-Efficient-BVP-solving-in-Julia","page":"Getting Started with BVP solving in Julia","title":"Get Started with Efficient BVP solving in Julia","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"When ordinary differential equations has constraints over the time span, we should model the differential equations as a boundary value problem which has the form of:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"fracdudt=f(u p t)\ng(u(a)u(b))=0","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"BoundaryValueDiffEq.jl addresses three types of BVProblem.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"General boundary value problems:, i.e., differential equations with constraints applied over the time span. This is a system where you would like to obtain the solution of the differential equations and make sure the solution satisfy the boundary conditions simutanously.\nGeneral second order boundary value problems, i.e., differential equations with constraints for both solution and derivative of solution applied over time span. This is a system where you would like to obtain the solution of the differential equations and make sure the solution satisfy the boundary conditions simutanously.\nBoundary value differential-algebraic equations, i.e., apart from constraints applied over the time span, BVDAE has additional algebraic equations which state the algebraic relationship of different states in BVDAE.","category":"page"},{"location":"tutorials/getting_started/#Solving-Linear-two-point-boundary-value-problem","page":"Getting Started with BVP solving in Julia","title":"Solving Linear two-point boundary value problem","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"Consider the linear two-point boundary value problem from standard BVP test problem.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"using BoundaryValueDiffEq\nfunction f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = u[1]\nend\nfunction bc!(res, u, p, t)\n    res[1] = u(0.0)[1] - 1\n    res[2] = u(1.0)[1]\nend\ntspan = (0.0, 1.0)\nu0 = [0.0, 0.0]\nprob = BVProblem(f!, bc!, u0, tspan)\nsol = solve(prob, MIRK4(), dt = 0.01)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"Since this proble only has constraints at the start and end of the time span, we can directly use TwoPointBVProblem:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"function f!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = u[1]\nend\nfunction bca!(res, ua, p)\n    res[1] = ua[1] - 1\nend\nfunction bcb!(res, ub, p)\n    res[1] = ub[1]\nend\ntspan = (0.0, 1.0)\nu0 = [0.0, 0.0]\nprob = TwoPointBVProblem(\n    f!, (bca!, bcb!), u0, tspan, bcresid_prototype = (zeros(1), zeros(1)))\nsol = solve(prob, MIRK4(), dt = 0.01)","category":"page"},{"location":"tutorials/getting_started/#Solving-second-order-boundary-value-problem","page":"Getting Started with BVP solving in Julia","title":"Solving second order boundary value problem","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"Consirder the test problem from example problems in MIRKN paper Muir and Adams [1].","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"begincases\ny_1(x)= y_2(x)\nepsilon y_2(x)=-y_1(x)y_2(x)- y_3(x)y_3(x)\nepsilon y_3(x)=y_1(x) y_3(x)- y_1(x) y_3 (x)\nendcases","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"with initial conditions:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"y_1(0) = y_1(0)= y_1(1)=y_1(1)=0y_3(0)=\n-1 y_3(1)=1","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"using BoundaryValueDiffEqMIRKN\nfunction f!(ddu, du, u, p, t)\n    ϵ = 0.1\n    ddu[1] = u[2]\n    ddu[2] = (-u[1] * du[2] - u[3] * du[3]) / ϵ\n    ddu[3] = (du[1] * u[3] - u[1] * du[3]) / ϵ\nend\nfunction bc!(res, du, u, p, t)\n    res[1] = u(0.0)[1]\n    res[2] = u(1.0)[1]\n    res[3] = u(0.0)[3] + 1\n    res[4] = u(1.0)[3] - 1\n    res[5] = du(0.0)[1]\n    res[6] = du(1.0)[1]\nend\nu0 = [1.0, 1.0, 1.0]\ntspan = (0.0, 1.0)\nprob = SecondOrderBVProblem(f!, bc!, u0, tspan)\nsol = solve(prob, MIRKN4(), dt = 0.01)","category":"page"},{"location":"tutorials/getting_started/#Solving-semi-expicit-boundary-value-differential-algebraic-equations","page":"Getting Started with BVP solving in Julia","title":"Solving semi-expicit boundary value differential-algebraic equations","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"Consider the nonlinear semi-explicit DAE of index at most 2 in COLDAE paper Ascher and Spiteri [2]","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"begincases\nx_1=(epsilon+x_2-p_2(t))y+p_1(t) \nx_2=p_2(t) \nx_3=y \n0=(x_1-p_1(t))(y-e^t)\nendcases","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"with boundary conditions","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"x_1(0)=0x_3(0)=1x_2(1)=sin(1)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started with BVP solving in Julia","title":"Getting Started with BVP solving in Julia","text":"using BoundaryValueDiffEqAscher\nfunction f!(du, u, p, t)\n    e = 2.7\n    du[1] = (1 + u[2] - sin(t)) * u[4] + cos(t)\n    du[2] = cos(t)\n    du[3] = u[4]\n    du[4] = (u[1] - sin(t)) * (u[4] - e^t)\nend\nfunction bc!(res, u, p, t)\n    res[1] = u[1]\n    res[2] = u[3] - 1\n    res[3] = u[2] - sin(1.0)\nend\nu0 = [0.0, 0.0, 0.0, 0.0]\ntspan = (0.0, 1.0)\nfun = BVPFunction(f!, bc!, mass_matrix = [1 0 0 0; 0 1 0 0; 0 0 1 0; 0 0 0 0])\nprob = BVProblem(fun, u0, tspan)\nsol = solve(prob, Ascher4(zeta = [0.0, 0.0, 1.0]), dt = 0.01)","category":"page"},{"location":"#BoundaryValueDiffEq.jl:-High-Performance-Bounday-Value-Problem-Solvers","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"","category":"section"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"BoundaryValueDiffEq.jl is a component package in the DifferentialEquations.jl ecosystem. The package includes its own high-performance BVP solvers which covers wide range of different kinds boundary value problems, includes the ability to swap out to fast direct and iterative nonlinear solvers, along with the ability to use sparse automatic differentiation for Jacobian construction and Jacobian-vector products.","category":"page"},{"location":"#Installation","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"Installation","text":"","category":"section"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"To install BoundaryValueDiffEq.jl, use the Julia package manager:","category":"page"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"using Pkg\nPkg.add(\"BoundaryValueDiffEq\")","category":"page"},{"location":"#Contributing","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"Contributing","text":"","category":"section"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"</details>","category":"page"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"</details>","category":"page"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"</details>","category":"page"},{"location":"","page":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","title":"BoundaryValueDiffEq.jl: High-Performance Bounday Value Problem Solvers","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" *\n                name *\n                \".jl/tree/gh-pages/v\" *\n                version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" *\n               name *\n               \".jl/tree/gh-pages/v\" *\n               version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"}]
}
