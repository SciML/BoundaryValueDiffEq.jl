<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BVP Functions and Jacobian Types · BoundaryValueDiffEq.jl</title><meta name="title" content="BVP Functions and Jacobian Types · BoundaryValueDiffEq.jl"/><meta property="og:title" content="BVP Functions and Jacobian Types · BoundaryValueDiffEq.jl"/><meta property="twitter:title" content="BVP Functions and Jacobian Types · BoundaryValueDiffEq.jl"/><meta name="description" content="Documentation for BoundaryValueDiffEq.jl."/><meta property="og:description" content="Documentation for BoundaryValueDiffEq.jl."/><meta property="twitter:description" content="Documentation for BoundaryValueDiffEq.jl."/><meta property="og:url" content="https://docs.sciml.ai/BoundaryValueDiffEq/stable/basics/bvp_functions/"/><meta property="twitter:url" content="https://docs.sciml.ai/BoundaryValueDiffEq/stable/basics/bvp_functions/"/><link rel="canonical" href="https://docs.sciml.ai/BoundaryValueDiffEq/stable/basics/bvp_functions/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="BoundaryValueDiffEq.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BoundaryValueDiffEq.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">BoundaryValueDiffEq.jl: High-Performance Boundary Value Problem Solvers</a></li><li><a class="tocitem" href="../../tutorials/getting_started/">Getting Started with BVP solving in Julia</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/continuation/">Solve BVP with Continuation</a></li><li><a class="tocitem" href="../../tutorials/solve_nlls_bvp/">Solve Overdetermined and Underdetermined BVP</a></li><li><a class="tocitem" href="../../tutorials/unknown_parameters/">Estimate Unknown Parameters in BVP</a></li><li><a class="tocitem" href="../../tutorials/extremum/">Solve BVP with Extremum Boundary Conditions</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../bvp_problem/">Boundary Value Problems</a></li><li class="is-active"><a class="tocitem" href>BVP Functions and Jacobian Types</a><ul class="internal"><li><a class="tocitem" href="#Function-Type-Definitions"><span>Function Type Definitions</span></a></li></ul></li><li><a class="tocitem" href="../solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../autodiff/">Automatic Differentiation Backends</a></li><li><a class="tocitem" href="../error_control/">Error Control Adaptivity</a></li></ul></li><li><span class="tocitem">Solver Summaries and Recommendations</span><ul><li><a class="tocitem" href="../../solvers/mirk/">BoundaryValueDiffEqMIRK</a></li><li><a class="tocitem" href="../../solvers/firk/">BoundaryValueDiffEqFIRK</a></li><li><a class="tocitem" href="../../solvers/shooting/">BoundaryValueDiffEqShooting</a></li><li><a class="tocitem" href="../../solvers/mirkn/">BoundaryValueDiffEqMIRKN</a></li><li><a class="tocitem" href="../../solvers/ascher/">BoundaryValueDiffEqAscher</a></li><li><a class="tocitem" href="../../solvers/simple_solvers/">SimpleBoundaryValueDiffEq</a></li><li><a class="tocitem" href="../../solvers/wrappers/">Wrapper Methods</a></li></ul></li><li><span class="tocitem">Wrapped Solver APIs</span><ul><li><a class="tocitem" href="../../api/odeinterface/">ODEInterface.jl</a></li></ul></li><li><span class="tocitem">Development Documentation</span><ul><li><a class="tocitem" href="../../devdocs/internal_interfaces/">Internal Abstract Types</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basics</a></li><li class="is-active"><a href>BVP Functions and Jacobian Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BVP Functions and Jacobian Types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/BoundaryValueDiffEq.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/BoundaryValueDiffEq.jl/blob/master/docs/src/basics/bvp_functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="bvpfunctions"><a class="docs-heading-anchor" href="#bvpfunctions">BVP Functions and Jacobian Types</a><a id="bvpfunctions-1"></a><a class="docs-heading-anchor-permalink" href="#bvpfunctions" title="Permalink"></a></h1><p>The SciML ecosystem provides an extensive interface for declaring extra functions associated with the boundary value probems&#39;s data. In traditional libraries, there is usually only few options: the Jacobian and the Jacobian of boundary conditions. However, we allow for a large array of pre-computed functions to speed up the calculations. This is offered via the <code>BVPFunction</code> types, which can be passed to the problems.</p><h2 id="Function-Type-Definitions"><a class="docs-heading-anchor" href="#Function-Type-Definitions">Function Type Definitions</a><a id="Function-Type-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Type-Definitions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.BVPFunction" href="#SciMLBase.BVPFunction"><code>SciMLBase.BVPFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>DocStringExtensions.TypeDefinition()</p><p>A representation of a BVP function <code>f</code>, defined by:</p><p class="math-container">\[\frac{du}{dt} = f(u, p, t)\]</p><p>and the constraints:</p><p class="math-container">\[g(u, p, t) = 0\]</p><p>If the size of <code>g(u, p, t)</code> is different from the size of <code>u</code>, then the constraints are interpreted as a least squares problem, i.e. the objective function is:</p><p class="math-container">\[\min_{u} \| g_i(u, p, t) \|^2\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><pre><code class="language-julia hljs">BVPFunction{iip, specialize}(f, bc;
    cost = __has_cost(f) ? f.cost : nothing,
    equality = __has_equality(f) ? f.equality : nothing,
    inequality = __has_inequality(f) ? f.inequality : nothing,
    mass_matrix = __has_mass_matrix(f) ? f.mass_matrix : I,
    analytic = __has_analytic(f) ? f.analytic : nothing,
    tgrad= __has_tgrad(f) ? f.tgrad : nothing,
    jac = __has_jac(f) ? f.jac : nothing,
    bcjac = __has_jac(bc) ? bc.jac : nothing,
    jvp = __has_jvp(f) ? f.jvp : nothing,
    vjp = __has_vjp(f) ? f.vjp : nothing,
    jac_prototype = __has_jac_prototype(f) ? f.jac_prototype : nothing,
    bcjac_prototype = __has_jac_prototype(bc) ? bc.jac_prototype : nothing,
    sparsity = __has_sparsity(f) ? f.sparsity : jac_prototype,
    paramjac = __has_paramjac(f) ? f.paramjac : nothing,
    syms = nothing,
    indepsym= nothing,
    paramsyms = nothing,
    colorvec = __has_colorvec(f) ? f.colorvec : nothing,
    bccolorvec = __has_colorvec(f) ? bc.colorvec : nothing,
    sys = __has_sys(f) ? f.sys : nothing,
    twopoint::Union{Val, Bool} = Val(false))</code></pre><p>Note that both the function <code>f</code> and boundary condition <code>bc</code> are required. <code>f</code> should be given as <code>f(du,u,p,t)</code> or <code>out = f(u,p,t)</code>. <code>bc</code> should be given as <code>bc(res, u, p, t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating the usage of <code>f</code> and <code>bc</code>. These include:</p><ul><li><code>cost(u, p)</code>: the target to be minimized, similar with the <code>cost</code> function in <code>OptimizationFunction</code>. This is used to define the objective function of the BVP, which can be minimized by optimization solvers.</li><li><code>equality(res, u, t)</code>: equality constraints functions for the BVP.</li><li><code>inequality(res, u, t)</code>: inequality constraints functions for the BVP.</li><li><code>mass_matrix</code>: the mass matrix <code>M</code> represented in the BVP function. Can be used to determine that the equation is actually a BVP for differential algebraic equation (DAE) if <code>M</code> is singular.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical solution of the BVP. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,u,h,p,t)</code> or dT=tgrad(u,p,t): returns <span>$\frac{\partial f(u,p,t)}{\partial t}$</span></li><li><code>jac(J,du,u,p,gamma,t)</code> or <code>J=jac(du,u,p,gamma,t)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>bcjac(J,du,u,p,gamma,t)</code> or <code>J=jac(du,u,p,gamma,t)</code>: returns <span>$\frac{dbc}{du}$</span></li><li><code>jvp(Jv,v,du,u,p,gamma,t)</code> or <code>Jv=jvp(v,du,u,p,gamma,t)</code>: returns the directional derivative <span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,du,u,p,gamma,t)</code> or <code>Jv=vjp(v,du,u,p,gamma,t)</code>: returns the adjoint derivative <span>$\frac{df}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>bcjac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li><li><code>bccolorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>bcjac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p>Additional Options:</p><ul><li><code>twopoint</code>: Specify that the BVP is a two-point boundary value problem. Use <code>Val(true)</code> or <code>Val(false)</code> for type stability.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>specialize: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the BVPFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.116.3/src/scimlfunctions.jl#L2205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.DynamicalBVPFunction" href="#SciMLBase.DynamicalBVPFunction"><code>SciMLBase.DynamicalBVPFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>DocStringExtensions.TypeDefinition()</p><p>A representation of a dynamical BVP function <code>f</code>, defined by:</p><p class="math-container">\[M \frac{ddu}{dt} = f(du,u,p,t)\]</p><p>along with its boundary condition:</p><p class="math-container">\[\]</p><p>and all of its related functions, such as the Jacobian of <code>f</code>, its gradient with respect to time, and more. For all cases, <code>u0</code> is the initial condition, <code>p</code> are the parameters, and <code>t</code> is the independent variable.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DynamicalBVPFunction{iip,specialize}(f, bc;
                                    mass_matrix = __has_mass_matrix(f) ? f.mass_matrix : I,
                                    analytic = __has_analytic(f) ? f.analytic : nothing,
                                    tgrad= __has_tgrad(f) ? f.tgrad : nothing,
                                    jac = __has_jac(f) ? f.jac : nothing,
                                    jvp = __has_jvp(f) ? f.jvp : nothing,
                                    vjp = __has_vjp(f) ? f.vjp : nothing,
                                    jac_prototype = __has_jac_prototype(f) ? f.jac_prototype : nothing,
                                    sparsity = __has_sparsity(f) ? f.sparsity : jac_prototype,
                                    paramjac = __has_paramjac(f) ? f.paramjac : nothing,
                                    colorvec = __has_colorvec(f) ? f.colorvec : nothing,
                                    sys = __has_sys(f) ? f.sys : nothing
                                    twopoint::Union{Val, Bool} = Val(false))</code></pre><p>Note that only the functions <code>f_i</code> themselves are required. These functions should be given as <code>f_i!(du,du,u,p,t)</code> or <code>ddu = f_i(du,u,p,t)</code>. See the section on <code>iip</code> for more details on in-place vs out-of-place handling.</p><p>All of the remaining functions are optional for improving or accelerating the usage of <code>f</code>. These include:</p><ul><li><code>mass_matrix</code>: the mass matrix <code>M_i</code> represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if <code>M</code> is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae<em>solve/. Must be an AbstractArray or an AbstractSciMLOperator. Should be given as a tuple of mass matrices, i.e. `(M</em>1, M_2)` for the mass matrices of equations 1 and 2 respectively.</li><li><code>analytic(u0,p,t)</code>: used to pass an analytical solution function for the analytical solution of the ODE. Generally only used for testing and development of the solvers.</li><li><code>tgrad(dT,du,u,p,t)</code> or dT=tgrad(du,u,p,t): returns <span>$\frac{\partial f(du,u,p,t)}{\partial t}$</span></li><li><code>jac(J,du,u,p,t)</code> or <code>J=jac(du,u,p,t)</code>: returns <span>$\frac{df}{du}$</span></li><li><code>jvp(Jv,v,u,p,t)</code> or <code>Jv=jvp(v,u,p,t)</code>: returns the directional derivative <span>$\frac{df}{du} v$</span></li><li><code>vjp(Jv,v,u,p,t)</code> or <code>Jv=vjp(v,u,p,t)</code>: returns the adjoint derivative <span>$\frac{df}{du}^\ast v$</span></li><li><code>jac_prototype</code>: a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized <code>Tridiagonal</code> matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a <code>SparseMatrixCSC</code> with a correct sparsity pattern for the Jacobian. The default is <code>nothing</code>, which means a dense Jacobian.</li><li><code>paramjac(pJ,du,u,p,t)</code>: returns the parameter Jacobian <span>$\frac{df}{dp}$</span>.</li><li><code>colorvec</code>: a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the <code>jac_prototype</code>. This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to <code>nothing</code>, which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern.</li></ul><p><strong>iip: In-Place vs Out-Of-Place</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>specialize: Controlling Compilation and Specialization</strong></p><p>For more details on this argument, see the ODEFunction documentation.</p><p><strong>Fields</strong></p><p>The fields of the DynamicalBVPFunction type directly match the names of the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.116.3/src/scimlfunctions.jl#L2351">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bvp_problem/">« Boundary Value Problems</a><a class="docs-footer-nextpage" href="../solve/">Common Solver Options (Solve Keyword Arguments) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 7 September 2025 14:48">Sunday 7 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
